{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Pixi is a package management tool for developers. It allows the developer to install libraries and applications in a reproducible way. Use pixi cross-platform, on Windows, Mac and Linux.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>pixi</code> you can run the following command in your terminal:</p> Linux &amp; macOSWindows <pre><code>curl -fsSL https://pixi.sh/install.sh | bash\n</code></pre> <p>The above invocation will automatically download the latest version of <code>pixi</code>, extract it, and move the <code>pixi</code> binary to <code>~/.pixi/bin</code>. If this directory does not already exist, the script will create it.</p> <p>The script will also update your <code>~/.bash_profile</code> to include <code>~/.pixi/bin</code> in your PATH, allowing you to invoke the <code>pixi</code> command from anywhere.</p> <p><code>PowerShell</code>: <pre><code>iwr -useb https://pixi.sh/install.ps1 | iex\n</code></pre> <code>winget</code>: <pre><code>winget install prefix-dev.pixi\n</code></pre> The above invocation will automatically download the latest version of <code>pixi</code>, extract it, and move the <code>pixi</code> binary to <code>LocalAppData/pixi/bin</code>. If this directory does not already exist, the script will create it.</p> <p>The command will also automatically add <code>LocalAppData/pixi/bin</code> to your path allowing you to invoke <code>pixi</code> from anywhere.</p> <p>Tip</p> <p>You might need to restart your terminal or source your shell for the changes to take effect.</p>"},{"location":"#autocompletion","title":"Autocompletion","text":"<p>To get autocompletion run:</p> Linux &amp; macOSWindows <pre><code># Pick your shell (use `echo $SHELL` to find the shell you are using.):\necho 'eval \"$(pixi completion --shell bash)\"' &gt;&gt; ~/.bashrc\necho 'eval \"$(pixi completion --shell zsh)\"' &gt;&gt; ~/.zshrc\necho 'pixi completion --shell fish | source' &gt;&gt; ~/.config/fish/config.fish\necho 'eval (pixi completion --shell elvish | slurp)' &gt;&gt; ~/.elvish/rc.elv\n</code></pre> <p>PowerShell: <pre><code>Add-Content -Path $PROFILE -Value '(&amp; pixi completion --shell powershell) | Out-String | Invoke-Expression'\n</code></pre></p> <p>And then restart the shell or source the shell config file.</p>"},{"location":"#alternative-installation-methods","title":"Alternative installation methods","text":"<p>Although we recommend installing pixi through the above method we also provide additional installation methods.</p>"},{"location":"#homebrew","title":"Homebrew","text":"<p>Pixi is available via homebrew. To install pixi via homebrew simply run:</p> <pre><code>brew install pixi\n</code></pre>"},{"location":"#windows-installer","title":"Windows installer","text":"<p>We provide an <code>msi</code> installer on our Github releases page. The installer will download pixi and add it to the path.</p>"},{"location":"#install-from-source","title":"Install from source","text":"<p>pixi is 100% written in Rust, and therefore it can be installed, built and tested with cargo. To start using pixi from a source build run:</p> <pre><code>cargo install --locked --git https://github.com/prefix-dev/pixi.git\n</code></pre> <p>or when you want to make changes use:</p> <pre><code>cargo build\ncargo test\n</code></pre> <p>If you have any issues building because of the dependency on <code>rattler</code> checkout it's compile steps</p>"},{"location":"#update","title":"Update","text":"<p>Updating is as simple as installing, rerunning the installation script gets you the latest version.</p> Linux &amp; macOSWindows <p><pre><code>curl -fsSL https://pixi.sh/install.sh | bash\n</code></pre> Or get a specific pixi version using: <pre><code>export PIXI_VERSION=vX.Y.Z &amp;&amp; curl -fsSL https://pixi.sh/install.sh | bash\n</code></pre></p> <p>PowerShell: <pre><code>iwr -useb https://pixi.sh/install.ps1 | iex\n</code></pre> Or get a specific pixi version using: PowerShell: <pre><code>$Env:PIXI_VERSION=\"vX.Y.Z\"; iwr -useb https://pixi.sh/install.ps1 | iex\n</code></pre></p> <p>Note</p> <p>If you used a package manager like <code>brew</code>, <code>mamba</code>, <code>conda</code>, <code>paru</code> to install <code>pixi</code>. Then use their builtin update mechanism. e.g. <code>brew update &amp;&amp; brew upgrade pixi</code></p>"},{"location":"#uninstall","title":"Uninstall","text":"<p>To uninstall pixi from your system, simply remove the binary.</p> Linux &amp; macOSWindows <pre><code>rm ~/.pixi/bin/pixi\n</code></pre> <pre><code>$PIXI_BIN = \"$Env:LocalAppData\\pixi\\bin\\pixi\"; Remove-Item -Path $PIXI_BIN\n</code></pre> <p>After this command, you can still use the tools you installed with pixi. To remove these as well, just remove the whole <code>~/.pixi</code> directory and remove the directory from your path.</p>"},{"location":"Community/","title":"Community","text":""},{"location":"Community/#built-using-pixi","title":"Built using Pixi","text":"<ul> <li>jiaxiyang/cpp_project_guideline: Guide the way beginners make their c++ projects.</li> <li>karelze/tclf: A python library for trade classification\u26a1</li> <li>quantco/polarify: Simplifying conditional Polars Expressions with Python \ud83d\udc0d \ud83d\udc3b\u200d\u2744\ufe0f</li> <li>quantco/slim-trees: Pickle your ML models more efficiently for deployment \ud83d\ude80</li> <li>hex-inc/vegafusion: Serverside scaling of Vega and Altair visualizations in Rust, Python, WASM, and Java</li> <li>pablovela5620/arxiv-researcher: Summarize PDF's and Arixv papers with Langchain and Nougat \ud83e\udd89</li> <li>HaoZeke/xtsci-dist: Incremental <code>scipy</code> port using <code>xtensor</code></li> <li>Ribasim: Water resources model</li> <li>LFortran: A modern cross-platform Fortran compiler</li> <li>Rerun: Rerun is an SDK for building time aware visualizations of multimodal data.</li> <li>conda-auth: a conda plugin providing more secure authentication support to conda.</li> <li>py-rattler: Build your own conda environment manager using the python wrapper of our Rattler backend.</li> </ul>"},{"location":"FAQ/","title":"Frequently asked questions","text":""},{"location":"FAQ/#what-is-the-difference-with-conda-mamba-poetry-pip","title":"What is the difference with <code>conda</code>, <code>mamba</code>, <code>poetry</code>, <code>pip</code>","text":"Tool Installs python Builds packages Runs predefined tasks Has lockfiles builtin Fast Use without python Conda \u2705 \u274c \u274c \u274c \u274c \u274c Mamba \u2705 \u274c \u274c \u274c \u2705 \u2705 Pip \u274c \u2705 \u274c \u274c \u274c \u274c Pixi \u2705 \ud83d\udea7 \u2705 \u2705 \u2705 \u2705 Poetry \u274c \u2705 \u274c \u2705 \u274c \u274c"},{"location":"FAQ/#why-the-name-pixi","title":"Why the name <code>pixi</code>","text":"<p>Starting with the name <code>prefix</code> we iterated until we had a name that was easy to pronounce, spell and remember. There also wasn't a cli tool yet using that name. Unlike <code>px</code>, <code>pex</code>, <code>pax</code>, etc. We think it sparks curiosity and fun, if you don't agree, I'm sorry, but you can always alias it to whatever you like.</p> Linux &amp; macOSWindows <pre><code>alias not_pixi=\"pixi\"\n</code></pre> <p>PowerShell: <pre><code>New-Alias -Name not_pixi -Value pixi\n</code></pre></p>"},{"location":"FAQ/#where-is-pixi-build","title":"Where is <code>pixi build</code>","text":"<p>TL;DR: It's coming we promise!</p> <p><code>pixi build</code> is going to be the subcommand that can generate a conda package out of a pixi project. This requires a solid build tool which we're creating with <code>rattler-build</code> which will be used as a library in pixi.</p>"},{"location":"basic_usage/","title":"Basic usage","text":"<p>Ensure you've got <code>pixi</code> set up. If running <code>pixi</code> doesn't show the help, see the getting started if it doesn't.</p> <pre><code>pixi\n</code></pre> <p>Initialize a new project and navigate to the project directory.</p> <pre><code>pixi init pixi-hello-world\ncd pixi-hello-world\n</code></pre> <p>Add the dependencies you would like to use.</p> <pre><code>pixi add python\n</code></pre> <p>Create a file named <code>hello_world.py</code> in the directory and paste the following code into the file.</p> hello_world.py<pre><code>def hello():\n    print(\"Hello World, to the new revolution in package management.\")\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre> <p>Run the code inside the environment.</p> <pre><code>pixi run python hello_world.py\n</code></pre> <p>You can also put this run command in a task.</p> <pre><code>pixi task add hello python hello_world.py\n</code></pre> <p>After adding the task, you can run the task using its name.</p> <pre><code>pixi run hello\n</code></pre> <p>Use the <code>shell</code> command to activate the environment and start a new shell in there.</p> <pre><code>pixi shell\npython\nexit\n</code></pre> <p>You've just learned the basic features of pixi:</p> <ol> <li>initializing a project</li> <li>adding a dependency.</li> <li>adding a task, and executing it.</li> <li>running a program.</li> </ol> <p>Feel free to play around with what you just learned like adding more tasks, dependencies or code.</p> <p>Happy coding!</p>"},{"location":"basic_usage/#use-pixi-as-a-global-installation-tool","title":"Use pixi as a global installation tool","text":"<p>Use pixi to install tools on your machine.</p> <p>Some notable examples:</p> <pre><code># Awesome cross shell prompt, huge tip when using pixi!\npixi global install starship\n\n# Want to try a different shell?\npixi global install fish\n\n# Install other prefix.dev tools\npixi global install rattler-build\n\n# Install a linter you want to use in multiple projects.\npixi global install ruff\n</code></pre>"},{"location":"cli/","title":"Commands","text":""},{"location":"cli/#global-options","title":"Global options","text":"<ul> <li><code>--verbose (-v|vv|vvv)</code> Increase the verbosity of the output messages, the -v|vv|vvv increases the level of verbosity respectively.</li> <li><code>--help (-h)</code> Shows help information, use <code>-h</code> to get the short version of the help.</li> <li><code>--version (-V)</code>: shows the version of pixi that is used.</li> <li><code>--quiet (-q)</code>: Decreases the amount of output.</li> <li><code>--color &lt;COLOR&gt;</code>: Whether the log needs to be colored [env: <code>PIXI_COLOR=</code>] [default: <code>auto</code>] [possible values: always, never, auto]. Pixi also honor the <code>FORCE_COLOR</code> and <code>NO_COLOR</code> environment variables. They both take precedence over <code>--color</code> and <code>PIXI_COLOR</code>.</li> </ul>"},{"location":"cli/#init","title":"<code>init</code>","text":"<p>This command is used to create a new project. It initializes a <code>pixi.toml</code> file and also prepares a <code>.gitignore</code> to prevent the environment from being added to <code>git</code>.</p>"},{"location":"cli/#arguments","title":"Arguments","text":"<ol> <li><code>[PATH]</code>: Where to place the project (defaults to current path) [default: .]</li> </ol>"},{"location":"cli/#options","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: specify a platform that the project supports. (Allowed to be used more than once)</li> <li><code>--import &lt;ENV_FILE&gt; (-i)</code>: Import an existing conda environment file, e.g. <code>environment.yml</code>.</li> </ul> <p>Importing an environment.yml</p> <p>When importing an environment, the <code>pixi.toml</code> will be created with the dependencies from the environment file. The <code>pixi.lock</code> will be created when you install the environment. We don't support <code>git+</code> urls as dependencies for pip packages and for the <code>defaults</code> channel we use <code>main</code>, <code>r</code> and <code>msys2</code> as the default channels.</p> <pre><code>pixi init myproject\npixi init ~/myproject\npixi init  # Initializes directly in the current directory.\npixi init --channel conda-forge --channel bioconda myproject\npixi init --platform osx-64 --platform linux-64 myproject\npixi init --import environment.yml\n</code></pre>"},{"location":"cli/#add","title":"<code>add</code>","text":"<p>Adds dependencies to the <code>pixi.toml</code>. It will only add if the package with its version constraint is able to work with rest of the dependencies in the project. More info on multi-platform configuration.</p>"},{"location":"cli/#arguments_1","title":"Arguments","text":"<ol> <li><code>&lt;SPECS&gt;</code>: The package(s) to add, space separated. The version constraint is optional.</li> </ol>"},{"location":"cli/#options_1","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--host</code>: Specifies a host dependency, important for building a package.</li> <li><code>--build</code>: Specifies a build dependency, important for building a package.</li> <li><code>--pypi</code>: Specifies a PyPI dependency, not a conda package.     Parses dependencies as PEP508 requirements, supporting extras and versions.     See configuration for details.</li> <li><code>--no-install</code>: Don't install the package to the environment, only add the package to the lock-file.</li> <li><code>--no-lockfile-update</code>: Don't update the lock-file, implies the <code>--no-install</code> flag.</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform for which the dependency should be added. (Allowed to be used more than once)</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the dependency should be added.</li> </ul> <pre><code>pixi add numpy\npixi add numpy pandas \"pytorch&gt;=1.8\"\npixi add \"numpy&gt;=1.22,&lt;1.24\"\npixi add --manifest-path ~/myproject/pixi.toml numpy\npixi add --host \"python&gt;=3.9.0\"\npixi add --build cmake\npixi add --pypi requests[security]\npixi add --platform osx-64 --build clang\npixi add --no-install numpy\npixi add --no-lockfile-update numpy\npixi add --feature featurex numpy\n</code></pre>"},{"location":"cli/#install","title":"<code>install</code>","text":"<p>Installs all dependencies specified in the lockfile <code>pixi.lock</code>. Which gets generated on <code>pixi add</code> or when you manually change the <code>pixi.toml</code> file and run <code>pixi install</code>.</p>"},{"location":"cli/#options_2","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lockfile. Without checking the status of the lockfile. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the <code>pixi.toml</code><sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> </ul> <pre><code>pixi install\npixi install --manifest-path ~/myproject/pixi.toml\npixi install --frozen\npixi install --locked\n</code></pre>"},{"location":"cli/#run","title":"<code>run</code>","text":"<p>The <code>run</code> commands first checks if the environment is ready to use. When you didn't run <code>pixi install</code> the run command will do that for you. The custom tasks defined in the <code>pixi.toml</code> are also available through the run command.</p> <p>You cannot run <code>pixi run source setup.bash</code> as <code>source</code> is not available in the <code>deno_task_shell</code> commandos and not an executable.</p>"},{"location":"cli/#arguments_2","title":"Arguments","text":"<ol> <li><code>[TASK]...</code>  The task you want to run in the projects environment, this can also be a normal command. And all arguments after the task will be passed to the task.</li> </ol>"},{"location":"cli/#options_3","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lockfile. Without checking the status of the lockfile. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the <code>pixi.toml</code><sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to run the task in, if none are provided the default environment will be used or a selector will be given to select the right environment.</li> </ul> <pre><code>pixi run python\npixi run cowpy \"Hey pixi user\"\npixi run --manifest-path ~/myproject/pixi.toml python\npixi run --frozen python\npixi run --locked python\n# If you have specified a custom task in the pixi.toml you can run it with run as well\npixi run build\n# Extra arguments will be passed to the tasks command.\npixi run task argument1 argument2\n\n# If you have multiple environments you can select the right one with the --environment flag.\npixi run --environment cuda python\n</code></pre> <p>Info</p> <p>In <code>pixi</code> the <code>deno_task_shell</code> is the underlying runner of the run command.   Checkout their documentation for the syntax and available commands.   This is done so that the run commands can be run across all platforms.</p> <p>Cross environment tasks</p> <p>If you're using the <code>depends_on</code> feature of the <code>tasks</code>, the tasks will be run in the order you specified them. The <code>depends_on</code> can be used cross environment, e.g. you have this <code>pixi.toml</code>:</p> pixi.toml <pre><code>[tasks]\nstart = { cmd = \"python start.py\", depends_on = [\"build\"] }\n\n[feature.build.tasks]\nbuild = \"cargo build\"\n[feature.build.dependencies]\nrust = \"&gt;=1.74\"\n\n[environments]\nbuild = [\"build\"]\n</code></pre> <p>Then you're able to run the <code>build</code> from the <code>build</code> environment and <code>start</code> from the default environment. By only calling: <pre><code>pixi run start\n</code></pre></p>"},{"location":"cli/#remove","title":"<code>remove</code>","text":"<p>Removes dependencies from the <code>pixi.toml</code>.</p>"},{"location":"cli/#arguments_3","title":"Arguments","text":"<ol> <li><code>&lt;DEPS&gt;...</code>: List of dependencies you wish to remove from the project.</li> </ol>"},{"location":"cli/#options_4","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--host</code>: Specifies a host dependency, important for building a package.</li> <li><code>--build</code>: Specifies a build dependency, important for building a package.</li> <li><code>--pypi</code>: Specifies a PyPI dependency, not a conda package.</li> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform from which the dependency should be removed.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature from which the dependency should be removed.</li> </ul> <pre><code>pixi remove numpy\npixi remove numpy pandas pytorch\npixi remove --manifest-path ~/myproject/pixi.toml numpy\npixi remove --host python\npixi remove --build cmake\npixi remove --pypi requests\npixi remove --platform osx-64 --build clang\npixi remove --feature featurex clang\npixi remove --feature featurex --platform osx-64 clang\npixi remove --feature featurex --platform osx-64 --build clang\n</code></pre>"},{"location":"cli/#task","title":"<code>task</code>","text":"<p>If you want to make a shorthand for a specific command you can add a task for it.</p>"},{"location":"cli/#options_5","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> </ul>"},{"location":"cli/#task-add","title":"<code>task add</code>","text":"<p>Add a task to the <code>pixi.toml</code>, use <code>--depends-on</code> to add tasks you want to run before this task, e.g. build before an execute task.</p>"},{"location":"cli/#arguments_4","title":"Arguments","text":"<ol> <li><code>&lt;NAME&gt;</code>: The name of the task.</li> <li><code>&lt;COMMAND&gt;</code>: The command to run. This can be more than one word.</li> </ol> <p>Info</p> <p>If you are using <code>$</code> for env variables they will be resolved before adding them to the task. If you want to use <code>$</code> in the task you need to escape it with a <code>\\</code>, e.g. <code>echo \\$HOME</code>.</p>"},{"location":"cli/#options_6","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: the platform for which this task should be added.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: the feature for which the task is added, if non provided the default tasks will be added.</li> <li><code>--depends-on &lt;DEPENDS_ON&gt;</code>: the task it depends on to be run before the one your adding.</li> <li><code>--cwd &lt;CWD&gt;</code>: the working directory for the task relative to the root of the project.</li> </ul> <pre><code>pixi task add cow cowpy \"Hello User\"\npixi task add tls ls --cwd tests\npixi task add test cargo t --depends-on build\npixi task add build-osx \"METAL=1 cargo build\" --platform osx-64\npixi task add train python train.py --feature cuda\n</code></pre> <p>This adds the following to the <code>pixi.toml</code>:</p> <pre><code>[tasks]\ncow = \"cowpy \\\"Hello User\\\"\"\ntls = { cmd = \"ls\", cwd = \"tests\" }\ntest = { cmd = \"cargo t\", depends_on = [\"build\"] }\n\n[target.osx-64.tasks]\nbuild-osx = \"METAL=1 cargo build\"\n\n[feature.cuda.tasks]\ntrain = \"python train.py\"\n</code></pre> <p>Which you can then run with the <code>run</code> command:</p> <pre><code>pixi run cow\n# Extra arguments will be passed to the tasks command.\npixi run test --test test1\n</code></pre>"},{"location":"cli/#task-remove","title":"<code>task remove</code>","text":"<p>Remove the task from the <code>pixi.toml</code></p>"},{"location":"cli/#arguments_5","title":"Arguments","text":"<ul> <li><code>&lt;NAMES&gt;</code>: The names of the tasks, space separated.</li> </ul>"},{"location":"cli/#options_7","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: the platform for which this task is removed.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: the feature for which the task is removed.</li> </ul> <pre><code>pixi task remove cow\npixi task remove --platform linux-64 test\npixi task remove --feature cuda task\n</code></pre>"},{"location":"cli/#task-alias","title":"<code>task alias</code>","text":"<p>Create an alias for a task.</p>"},{"location":"cli/#arguments_6","title":"Arguments","text":"<ol> <li><code>&lt;ALIAS&gt;</code>: The alias name</li> <li><code>&lt;DEPENDS_ON&gt;</code>: The names of the tasks you want to execute on this alias, order counts, first one runs first.</li> </ol>"},{"location":"cli/#options_8","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: the platform for which this alias is created.</li> </ul> <pre><code>pixi task alias test-all test-py test-cpp test-rust\npixi task alias --platform linux-64 test test-linux\npixi task alias moo cow\n</code></pre>"},{"location":"cli/#task-list","title":"<code>task list</code>","text":"<p>List all tasks in the project.</p>"},{"location":"cli/#options_9","title":"Options","text":"<ul> <li><code>--environment</code>(<code>-e</code>): the environment's tasks list, if non is provided the default tasks will be listed.</li> <li><code>--summary</code>(<code>-s</code>): the output gets formatted to be machine parsable. (Used in the autocompletion of <code>pixi run</code>).</li> </ul> <pre><code>pixi task list\npixi task list --environment cuda\npixi task list --summary\n</code></pre>"},{"location":"cli/#list","title":"<code>list</code>","text":"<p>List project's packages. Highlighted packages are explicit dependencies.</p>"},{"location":"cli/#options_10","title":"Options","text":"<ul> <li><code>--platform &lt;PLATFORM&gt; (-p)</code>: The platform to list packages for. Defaults to the current platform</li> <li><code>--json</code>: Whether to output in json format.</li> <li><code>--json-pretty</code>: Whether to output in pretty json format</li> <li><code>--sort-by &lt;SORT_BY&gt;</code>: Sorting strategy [default: name] [possible values: size, name, type]</li> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: The path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--environment</code>(<code>-e</code>): The environment's packages to list, if non is provided the default environment's packages will be listed.</li> <li><code>--frozen</code>: Install the environment as defined in the lockfile. Without checking the status of the lockfile. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: Only install if the <code>pixi.lock</code> is up-to-date with the <code>pixi.toml</code><sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--no-install</code>: Don't install the environment for pypi solving, only update the lock-file if it can solve without installing. (Implied by <code>--frozen</code> and <code>--locked</code>)</li> </ul> <p><pre><code>```shell\npixi list\npixi list --json-pretty\npixi list --sort-by size\npixi list --platform win-64\npixi list --environment cuda\npixi list --frozen\npixi list --locked\npixi list --no-install\n</code></pre> Output will look like this, where <code>python</code> will be green as it is the package that was explicitly added to the <code>pixi.toml</code>:</p> <pre><code>\u279c pixi list\n Package           Version     Build               Size       Kind   Source\n _libgcc_mutex     0.1         conda_forge         2.5 KiB    conda  _libgcc_mutex-0.1-conda_forge.tar.bz2\n _openmp_mutex     4.5         2_gnu               23.1 KiB   conda  _openmp_mutex-4.5-2_gnu.tar.bz2\n bzip2             1.0.8       hd590300_5          248.3 KiB  conda  bzip2-1.0.8-hd590300_5.conda\n ca-certificates   2023.11.17  hbcca054_0          150.5 KiB  conda  ca-certificates-2023.11.17-hbcca054_0.conda\n ld_impl_linux-64  2.40        h41732ed_0          688.2 KiB  conda  ld_impl_linux-64-2.40-h41732ed_0.conda\n libexpat          2.5.0       hcb278e6_1          76.2 KiB   conda  libexpat-2.5.0-hcb278e6_1.conda\n libffi            3.4.2       h7f98852_5          56.9 KiB   conda  libffi-3.4.2-h7f98852_5.tar.bz2\n libgcc-ng         13.2.0      h807b86a_4          755.7 KiB  conda  libgcc-ng-13.2.0-h807b86a_4.conda\n libgomp           13.2.0      h807b86a_4          412.2 KiB  conda  libgomp-13.2.0-h807b86a_4.conda\n libnsl            2.0.1       hd590300_0          32.6 KiB   conda  libnsl-2.0.1-hd590300_0.conda\n libsqlite         3.44.2      h2797004_0          826 KiB    conda  libsqlite-3.44.2-h2797004_0.conda\n libuuid           2.38.1      h0b41bf4_0          32.8 KiB   conda  libuuid-2.38.1-h0b41bf4_0.conda\n libxcrypt         4.4.36      hd590300_1          98 KiB     conda  libxcrypt-4.4.36-hd590300_1.conda\n libzlib           1.2.13      hd590300_5          60.1 KiB   conda  libzlib-1.2.13-hd590300_5.conda\n ncurses           6.4         h59595ed_2          863.7 KiB  conda  ncurses-6.4-h59595ed_2.conda\n openssl           3.2.0       hd590300_1          2.7 MiB    conda  openssl-3.2.0-hd590300_1.conda\n python            3.12.1      hab00c5b_1_cpython  30.8 MiB   conda  python-3.12.1-hab00c5b_1_cpython.conda\n readline          8.2         h8228510_1          274.9 KiB  conda  readline-8.2-h8228510_1.conda\n tk                8.6.13      noxft_h4845f30_101  3.2 MiB    conda  tk-8.6.13-noxft_h4845f30_101.conda\n tzdata            2023d       h0c530f3_0          116.8 KiB  conda  tzdata-2023d-h0c530f3_0.conda\n xz                5.2.6       h166bdaf_0          408.6 KiB  conda  xz-5.2.6-h166bdaf_0.tar.bz2\n</code></pre>"},{"location":"cli/#shell","title":"<code>shell</code>","text":"<p>This command starts a new shell in the project's environment. To exit the pixi shell, simply run <code>exit</code>.</p>"},{"location":"cli/#options_11","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lockfile. Without checking the status of the lockfile. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the <code>pixi.toml</code><sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to activate the shell in, if none are provided the default environment will be used or a selector will be given to select the right environment.</li> </ul> <pre><code>pixi shell\nexit\npixi shell --manifest-path ~/myproject/pixi.toml\nexit\npixi shell --frozen\nexit\npixi shell --locked\nexit\npixi shell --environment cuda\nexit\n</code></pre>"},{"location":"cli/#shell-hook","title":"<code>shell-hook</code>","text":"<p>This command prints the activation script of an environment.</p>"},{"location":"cli/#options_12","title":"Options","text":"<ul> <li><code>--shell &lt;SHELL&gt; (-s)</code>: The shell for which the activation script should be printed. Defaults to the current shell.     Currently supported variants: [<code>bash</code>,  <code>zsh</code>,  <code>xonsh</code>,  <code>cmd</code>,  <code>powershell</code>,  <code>fish</code>,  <code>nushell</code>]</li> <li><code>--manifest-path</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--frozen</code>: install the environment as defined in the lockfile. Without checking the status of the lockfile. It can also be controlled by the <code>PIXI_FROZEN</code> environment variable (example: <code>PIXI_FROZEN=true</code>).</li> <li><code>--locked</code>: only install if the <code>pixi.lock</code> is up-to-date with the <code>pixi.toml</code><sup>1</sup>. It can also be controlled by the <code>PIXI_LOCKED</code> environment variable (example: <code>PIXI_LOCKED=true</code>). Conflicts with <code>--frozen</code>.</li> <li><code>--environment &lt;ENVIRONMENT&gt; (-e)</code>: The environment to activate, if none are provided the default environment will be used or a selector will be given to select the right environment.</li> </ul> <p><pre><code>pixi shell-hook\npixi shell-hook --shell bash\npixi shell-hook --shell zsh\npixi shell-hook -s powershell\npixi shell-hook --manifest-path ~/myproject/pixi.toml\npixi shell-hook --frozen\npixi shell-hook --locked\npixi shell-hook --environment cuda\n</code></pre> Example use-case, when you want to get rid of the <code>pixi</code> executable in a Docker container. <pre><code>pixi shell-hook --shell bash &gt; /etc/profile.d/pixi.sh\nrm ~/.pixi/bin/pixi # Now the environment will be activated without the need for the pixi executable.\n</code></pre></p>"},{"location":"cli/#search","title":"<code>search</code>","text":"<p>Search a package, output will list the latest version of the package.</p>"},{"location":"cli/#arguments_7","title":"Arguments","text":"<ol> <li><code>&lt;PACKAGE&gt;</code>:  Name of package to search, it's possible to use wildcards (<code>*</code>).</li> </ol>"},{"location":"cli/#options_13","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> <li><code>--limit &lt;LIMIT&gt; (-l)</code>: Limit the number of search results (default: 15)</li> </ul> <pre><code>pixi search pixi\npixi search -l 30 py*\npixi search -c robostack plotjuggler*\n</code></pre>"},{"location":"cli/#self-update","title":"<code>self-update</code>","text":"<p>Update pixi to the latest version or a specific version. If the pixi binary is not found in the default location (e.g. <code>~/.pixi/bin/pixi</code>), pixi won't update to prevent breaking the current installation (Homebrew, etc.). The behaviour can be overridden with the <code>--force</code> flag</p>"},{"location":"cli/#options_14","title":"Options","text":"<ul> <li><code>--version &lt;VERSION&gt;</code>: The desired version (to downgrade or upgrade to). Update to the latest version if not specified.</li> <li><code>--force</code>: Force the update even if the pixi binary is not found in the default location.</li> </ul> <pre><code>pixi self-update\npixi self-update --version 0.13.0\npixi self-update --force\n</code></pre>"},{"location":"cli/#info","title":"<code>info</code>","text":"<p>Shows helpful information about the pixi installation, cache directories, disk usage, and more. More information here.</p>"},{"location":"cli/#options_15","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> <li><code>--extended</code>: extend the information with more slow queries to the system, like directory sizes.</li> <li><code>--json</code>: Get a machine-readable version of the information as output.</li> </ul> <pre><code>pixi info\npixi info --json --extended\n</code></pre>"},{"location":"cli/#upload","title":"<code>upload</code>","text":"<p>Upload a package to a prefix.dev channel</p>"},{"location":"cli/#arguments_8","title":"Arguments","text":"<ol> <li><code>&lt;HOST&gt;</code>: The host + channel to upload to.</li> <li><code>&lt;PACKAGE_FILE&gt;</code>: The package file to upload.</li> </ol> <pre><code>pixi upload repo.prefix.dev/my_channel my_package.conda\n</code></pre>"},{"location":"cli/#auth","title":"<code>auth</code>","text":"<p>This command is used to authenticate the user's access to remote hosts such as <code>prefix.dev</code> or <code>anaconda.org</code> for private channels.</p>"},{"location":"cli/#auth-login","title":"<code>auth login</code>","text":"<p>Store authentication information for given host.</p> <p>Tip</p> <p>The host is real hostname not a channel.</p>"},{"location":"cli/#arguments_9","title":"Arguments","text":"<ol> <li><code>&lt;HOST&gt;</code>: The host to authenticate with.</li> </ol>"},{"location":"cli/#options_16","title":"Options","text":"<ul> <li><code>--token &lt;TOKEN&gt;</code>: The token to use for authentication with prefix.dev.</li> <li><code>--username &lt;USERNAME&gt;</code>: The username to use for basic HTTP authentication</li> <li><code>--password &lt;PASSWORD&gt;</code>: The password to use for basic HTTP authentication.</li> <li><code>--conda-token &lt;CONDA_TOKEN&gt;</code>: The token to use on <code>anaconda.org</code> / <code>quetz</code> authentication.</li> </ul> <pre><code>pixi auth login repo.prefix.dev --token pfx_JQEV-m_2bdz-D8NSyRSaNdHANx0qHjq7f2iD\npixi auth login anaconda.org --conda-token ABCDEFGHIJKLMNOP\npixi auth login https://myquetz.server --user john --password xxxxxx\n</code></pre>"},{"location":"cli/#auth-logout","title":"<code>auth logout</code>","text":"<p>Remove authentication information for a given host.</p>"},{"location":"cli/#arguments_10","title":"Arguments","text":"<ol> <li><code>&lt;HOST&gt;</code>: The host to authenticate with.</li> </ol> <pre><code>pixi auth logout &lt;HOST&gt;\npixi auth logout repo.prefix.dev\npixi auth logout anaconda.org\n</code></pre>"},{"location":"cli/#global","title":"<code>global</code>","text":"<p>Global is the main entry point for the part of pixi that executes on the global(system) level.</p> <p>Tip</p> <p>Binaries and environments installed globally are stored in <code>~/.pixi</code> by default, this can be changed by setting the <code>PIXI_HOME</code> environment variable.</p>"},{"location":"cli/#global-install","title":"<code>global install</code>","text":"<p>This command installs a package into its own environment and adds the binary to <code>PATH</code>, allowing you to access it anywhere on your system without activating the environment.</p>"},{"location":"cli/#arguments_11","title":"Arguments","text":"<p>1.<code>&lt;PACKAGE&gt;</code>: The package to install, this can also be a version constraint.</p>"},{"location":"cli/#options_17","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> </ul> <pre><code>pixi global install ruff\npixi global install starship\npixi global install --channel conda-forge --channel bioconda trackplot\n# Or in a more concise form\npixi global install -c conda-forge -c bioconda trackplot\n\n# Support full conda matchspec\npixi global install python=3.9.*\npixi global install \"python [version='3.11.0', build_number=1]\"\npixi global install \"python [version='3.11.0', build=he550d4f_1_cpython]\"\npixi global install python=3.11.0=h10a6764_1_cpython\n</code></pre> <p>After using global install, you can use the package you installed anywhere on your system.</p>"},{"location":"cli/#global-list","title":"<code>global list</code>","text":"<p>This command shows the current installed global environments including what binaries come with it. A global installed package/environment can possibly contain multiple binaries. Here is an example of a few installed packages:</p> <pre><code>&gt; pixi global list\nGlobally installed binary packages:\n  -  [package] starship\n     -  [bin] starship\n  -  [package] pre-commit\n     -  [bin] pre-commit\n  -  [package] grayskull\n     -  [bin] grayskull\n     -  [bin] greyskull\n     -  [bin] conda-grayskull\n     -  [bin] conda-greyskull\n  -  [package] zsh\n     -  [bin] zsh\n     -  [bin] zsh-5\n</code></pre>"},{"location":"cli/#global-upgrade","title":"<code>global upgrade</code>","text":"<p>This command upgrades a globally installed package to the latest version.</p>"},{"location":"cli/#arguments_12","title":"Arguments","text":"<ol> <li><code>&lt;PACKAGE&gt;</code>: The package to upgrade.</li> </ol>"},{"location":"cli/#options_18","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> </ul> <pre><code>pixi global upgrade ruff\npixi global upgrade --channel conda-forge --channel bioconda trackplot\n# Or in a more concise form\npixi global upgrade -c conda-forge -c bioconda trackplot\n</code></pre>"},{"location":"cli/#global-upgrade-all","title":"<code>global upgrade-all</code>","text":"<p>This command upgrades all globally installed packages to their latest version.</p>"},{"location":"cli/#options_19","title":"Options","text":"<ul> <li><code>--channel &lt;CHANNEL&gt; (-c)</code>: specify a channel that the project uses. Defaults to <code>conda-forge</code>. (Allowed to be used more than once)</li> </ul> <pre><code>pixi global upgrade-all\npixi global upgrade-all --channel conda-forge --channel bioconda\n# Or in a more concise form\npixi global upgrade-all -c conda-forge -c bioconda trackplot\n</code></pre>"},{"location":"cli/#global-remove","title":"<code>global remove</code>","text":"<p>Removes a package previously installed into a globally accessible location via <code>pixi global install</code></p> <p>Use <code>pixi global info</code> to find out what the package name is that belongs to the tool you want to remove.</p>"},{"location":"cli/#arguments_13","title":"Arguments","text":"<ol> <li><code>&lt;PACKAGE&gt;</code>: The package to remove.</li> </ol> <pre><code>pixi global remove pre-commit\n</code></pre>"},{"location":"cli/#project","title":"<code>project</code>","text":"<p>This subcommand allows you to modify the project configuration through the command line interface.</p>"},{"location":"cli/#options_20","title":"Options","text":"<ul> <li><code>--manifest-path &lt;MANIFEST_PATH&gt;</code>: the path to <code>pixi.toml</code>, by default it searches for one in the parent directories.</li> </ul>"},{"location":"cli/#project-channel-add","title":"<code>project channel add</code>","text":"<p>Add channels to the channel list in the project configuration. When you add channels, the channels are tested for existence, added to the lockfile and the environment is reinstalled.</p>"},{"location":"cli/#arguments_14","title":"Arguments","text":"<ol> <li><code>&lt;CHANNEL&gt;</code>: The channels to add, name or URL.</li> </ol>"},{"location":"cli/#options_21","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the channel is added.</li> </ul> <pre><code>pixi project channel add robostack\npixi project channel add bioconda conda-forge robostack\npixi project channel add file:///home/user/local_channel\npixi project channel add https://repo.prefix.dev/conda-forge\npixi project channel add --no-install robostack\npixi project channel add --feature cuda nividia\n</code></pre>"},{"location":"cli/#project-channel-list","title":"<code>project channel list</code>","text":"<p>List the channels in the project file</p>"},{"location":"cli/#options_22","title":"Options","text":"<ul> <li><code>urls</code>: show the urls of the channels instead of the names.</li> </ul> <pre><code>$ pixi project channel list\nEnvironment: default\n- conda-forge\n\n$ pixi project channel list --urls\nEnvironment: default\n- https://conda.anaconda.org/conda-forge/\n</code></pre>"},{"location":"cli/#project-channel-remove","title":"<code>project channel remove</code>","text":"<p>List the channels in the project file</p>"},{"location":"cli/#arguments_15","title":"Arguments","text":"<ol> <li><code>&lt;CHANNEL&gt;...</code>: The channels to remove, name(s) or URL(s).</li> </ol>"},{"location":"cli/#options_23","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the channel is removed.</li> </ul> <pre><code>pixi project channel remove conda-forge\npixi project channel remove https://conda.anaconda.org/conda-forge/\npixi project channel remove --no-install conda-forge\npixi project channel remove --feature cuda nividia\n</code></pre>"},{"location":"cli/#project-description-get","title":"<code>project description get</code>","text":"<p>Get the project description.</p> <pre><code>$ pixi project description get\nPackage management made easy!\n</code></pre>"},{"location":"cli/#project-description-set","title":"<code>project description set</code>","text":"<p>Set the project description.</p>"},{"location":"cli/#arguments_16","title":"Arguments","text":"<ol> <li><code>&lt;DESCRIPTION&gt;</code>: The description to set.</li> </ol> <pre><code>pixi project description set \"my new description\"\n</code></pre>"},{"location":"cli/#project-platform-add","title":"<code>project platform add</code>","text":"<p>Adds a platform(s) to the project file and updates the lockfile.</p>"},{"location":"cli/#arguments_17","title":"Arguments","text":"<ol> <li><code>&lt;PLATFORM&gt;...</code>: The platforms to add.</li> </ol>"},{"location":"cli/#options_24","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the platform will be added.</li> </ul> <pre><code>pixi project platform add win-64\npixi project platform add --feature test win-64\n</code></pre>"},{"location":"cli/#project-platform-list","title":"<code>project platform list</code>","text":"<p>List the platforms in the project file.</p> <pre><code>$ pixi project platform list\nosx-64\nlinux-64\nwin-64\nosx-arm64\n</code></pre>"},{"location":"cli/#project-platform-remove","title":"<code>project platform remove</code>","text":"<p>Remove platform(s) from the project file and updates the lockfile.</p>"},{"location":"cli/#arguments_18","title":"Arguments","text":"<ol> <li><code>&lt;PLATFORM&gt;...</code>: The platforms to remove.</li> </ol>"},{"location":"cli/#options_25","title":"Options","text":"<ul> <li><code>--no-install</code>: do not update the environment, only add changed packages to the lock-file.</li> <li><code>--feature &lt;FEATURE&gt; (-f)</code>: The feature for which the platform will be removed.</li> </ul> <pre><code>pixi project platform remove win-64\npixi project platform remove --feature test win-64\n</code></pre>"},{"location":"cli/#project-version-get","title":"<code>project version get</code>","text":"<p>Get the project version.</p> <pre><code>$ pixi project version get\n0.11.0\n</code></pre>"},{"location":"cli/#project-version-set","title":"<code>project version set</code>","text":"<p>Set the project version.</p>"},{"location":"cli/#arguments_19","title":"Arguments","text":"<ol> <li><code>&lt;VERSION&gt;</code>: The version to set.</li> </ol> <pre><code>pixi project version set \"0.13.0\"\n</code></pre>"},{"location":"cli/#project-version-majorminorpatch","title":"<code>project version {major|minor|patch}</code>","text":"<p>Bump the project version to {MAJOR|MINOR|PATCH}.</p> <pre><code>pixi project version major\npixi project version minor\npixi project version patch\n</code></pre> <ol> <li> <p>An up-to-date lockfile means that the dependencies in the lockfile are allowed by the dependencies in the manifest file. For example</p> <ul> <li>a <code>pixi.toml</code> with <code>python = \"&gt;= 3.11\"</code> is up-to-date with a <code>name: python, version: 3.11.0</code> in the <code>pixi.lock</code>.</li> <li>a <code>pixi.toml</code> with <code>python = \"&gt;= 3.12\"</code> is not up-to-date with a <code>name: python, version: 3.11.0</code> in the <code>pixi.lock</code>.</li> </ul> <p>Being up-to-date does not mean that the lockfile holds the latest version available on the channel for the given dependency.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>The <code>pixi.toml</code> is the pixi project configuration file, also known as the project manifest.</p> <p>A <code>toml</code> file is structured in different tables. This document will explain the usage of the different tables. For more technical documentation check crates.io.</p>"},{"location":"configuration/#the-project-table","title":"The <code>project</code> table","text":"<p>The minimally required information in the <code>project</code> table is: <pre><code>[project]\nname = \"project-name\"\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\"]\n</code></pre></p>"},{"location":"configuration/#name","title":"<code>name</code>","text":"<p>The name of the project. <pre><code>[project]\nname = \"project-name\"\n</code></pre></p>"},{"location":"configuration/#channels","title":"<code>channels</code>","text":"<p>This is a list that defines the channels used to fetch the packages from. If you want to use channels hosted on <code>anaconda.org</code> you only need to use the name of the channel directly. <pre><code>[project]\nchannels = [\"conda-forge\", \"robostack\", \"bioconda\", \"nvidia\", \"pytorch\"]\n</code></pre></p> <p>Channels situated on the file system are also supported with absolute file paths: <pre><code>[project]\nchannels = [\"conda-forge\", \"file:///home/user/staged-recipes/build_artifacts\"]\n</code></pre></p> <p>To access private or public channels on prefix.dev or Quetz use the url including the hostname: <pre><code>[project]\nchannels = [\"conda-forge\", \"https://repo.prefix.dev/channel-name\"]\n</code></pre></p>"},{"location":"configuration/#platforms","title":"<code>platforms</code>","text":"<p>Defines the list of platforms that the project supports. Pixi solves the dependencies for all these platforms and puts them in the lockfile (<code>pixi.lock</code>).</p> <p><pre><code>[project]\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n</code></pre> The available platforms are listed here: link</p>"},{"location":"configuration/#version-optional","title":"<code>version</code> (optional)","text":"<p>The version of the project. This should be a valid version based on the conda Version Spec. See the version documentation, for an explanation of what is allowed in a Version Spec. <pre><code>[project]\nversion = \"1.2.3\"\n</code></pre></p>"},{"location":"configuration/#authors-optional","title":"<code>authors</code> (optional)","text":"<p>This is a list of authors of the project. <pre><code>[project]\nauthors = [\"John Doe &lt;j.doe@prefix.dev&gt;\", \"Marie Curie &lt;mss1867@gmail.com&gt;\"]\n</code></pre></p>"},{"location":"configuration/#description-optional","title":"<code>description</code> (optional)","text":"<p>This should contain a short description of the project. <pre><code>[project]\ndescription = \"A simple description\"\n</code></pre></p>"},{"location":"configuration/#license-optional","title":"<code>license</code> (optional)","text":"<p>The license as a valid SPDX string (e.g. MIT AND Apache-2.0) <pre><code>[project]\nlicense = \"MIT\"\n</code></pre></p>"},{"location":"configuration/#license-file-optional","title":"<code>license-file</code> (optional)","text":"<p>Relative path to the license file. <pre><code>[project]\nlicense-file = \"LICENSE.md\"\n</code></pre></p>"},{"location":"configuration/#readme-optional","title":"<code>readme</code> (optional)","text":"<p>Relative path to the README file. <pre><code>[project]\nreadme = \"README.md\"\n</code></pre></p>"},{"location":"configuration/#homepage-optional","title":"<code>homepage</code> (optional)","text":"<p>URL of the project homepage. <pre><code>[project]\nhomepage = \"https://pixi.sh\"\n</code></pre></p>"},{"location":"configuration/#repository-optional","title":"<code>repository</code> (optional)","text":"<p>URL of the project source repository. <pre><code>[project]\nrepository = \"https://github.com/prefix-dev/pixi\"\n</code></pre></p>"},{"location":"configuration/#documentation-optional","title":"<code>documentation</code> (optional)","text":"<p>URL of the project documentation. <pre><code>[project]\ndocumentation = \"https://pixi.sh\"\n</code></pre></p>"},{"location":"configuration/#the-tasks-table","title":"The <code>tasks</code> table","text":"<p>Tasks are a way to automate certain custom commands in your project. For example, a <code>lint</code> or <code>format</code> step. Tasks in a pixi project are essentially cross-platform shell commands, with a unified syntax across platforms. For more in-depth information, check the Advanced tasks documentation. Pixi's tasks are run in a pixi environment using <code>pixi run</code> and are executed using the <code>deno_task_shell</code>.</p> <p><pre><code>[tasks]\nsimple = \"echo This is a simple task\"\ncmd = { cmd=\"echo Same as a simple task but now more verbose\"}\ndepending = { cmd=\"echo run after simple\", depends_on=\"simple\"}\nalias = { depends_on=[\"depending\"]}\n</code></pre> You can modify this table using <code>pixi task</code>.</p> <p>Note</p> <p>Specify different tasks for different platforms using the target table</p>"},{"location":"configuration/#the-system-requirements-table","title":"The <code>system-requirements</code> table","text":"<p>The system requirements are used to define minimal system specifications used during dependency resolution. For example, we can define a unix system with a specific minimal libc version. This will be the minimal system specification for the project. System specifications are directly related to the virtual packages.</p> <p>Currently, the specified defaults are the same as conda-lock's implementation:</p> LinuxWindowsOsxOsx-arm64 default system requirements for linux<pre><code>[system-requirements]\nlinux = \"5.10\"\nlibc = { family=\"glibc\", version=\"2.17\" }\n</code></pre> default system requirements for windows<pre><code>[system-requirements]\n</code></pre> default system requirements for osx<pre><code>[system-requirements]\nmacos = \"10.15\"\n</code></pre> default system requirements for osx-arm64<pre><code>[system-requirements]\nmacos = \"11.0\"\n</code></pre> <p>Only if a project requires a different set should you define them.</p> <p>For example, when installing environments on old versions of linux. You may encounter the following error: <pre><code>\u00d7 The current system has a mismatching virtual package. The project requires '__linux' to be at least version '5.10' but the system has version '4.12.14'\n</code></pre> This suggests that the system requirements for the project should be lowered. To fix this, add the following table to your configuration: <pre><code>[system-requirements]\nlinux = \"4.12.14\"\n</code></pre></p>"},{"location":"configuration/#using-cuda-in-pixi","title":"Using Cuda in pixi","text":"<p>If you want to use <code>cuda</code> in your project you need to add the following to your <code>system-requirements</code> table: <pre><code>[system-requirements]\ncuda = \"11\" # or any other version of cuda you want to use\n</code></pre> This informs the solver that cuda is going to be available, so it can lock it into the lockfile if needed.</p>"},{"location":"configuration/#the-dependencies-tables","title":"The <code>dependencies</code> table(s)","text":"<p>This section defines what dependencies you would like to use for your project.</p> <p>There are multiple dependencies tables. The default is <code>[dependencies]</code>, which are dependencies that are shared across platforms.</p> <p>Dependencies are defined using a VersionSpec. A <code>VersionSpec</code> combines a Version with an optional operator.</p> <p>Some examples are: <pre><code># Use this exact package version\npackage0 = \"1.2.3\"\n# Use 1.2.3 up to 1.3.0\npackage1 = \"~=1.2.3\"\n# Use larger than 1.2 lower and equal to 1.4\npackage2 = \"&gt;1.2,&lt;=1.4\"\n# Bigger or equal than 1.2.3 or lower not including 1.0.0\npackage3 = \"&gt;=1.2.3|&lt;1.0.0\"\n</code></pre></p> <p>Dependencies can also be defined as a mapping where it is using a matchspec: <pre><code>package0 = { version = \"&gt;=1.2.3\", channel=\"conda-forge\" }\npackage1 = { version = \"&gt;=1.2.3\", build=\"py34_0\" }\n</code></pre></p> <p>Tip</p> <p>The dependencies can be easily added using the <code>pixi add</code> command line. Running <code>add</code> for an existing dependency will replace it with the newest it can use.</p> <p>Note</p> <p>To specify different dependencies for different platforms use the target table</p>"},{"location":"configuration/#dependencies","title":"<code>dependencies</code>","text":"<p>Add any conda package dependency that you want to install into the environment. Don't forget to add the channel to the project table should you use anything different than <code>conda-forge</code>. Even if the dependency defines a channel that channel should be added to the <code>project.channels</code> list.</p> <pre><code>[dependencies]\npython = \"&gt;3.9,&lt;=3.11\"\nrust = \"1.72\"\npytorch-cpu = { version = \"~=1.1\", channel = \"pytorch\" }\n</code></pre>"},{"location":"configuration/#pypi-dependencies-beta-feature","title":"<code>pypi-dependencies</code> (Beta feature)","text":"<p>Add any PyPI package that you want to install in the environment after the conda installation is finished. These are not available on prefix.dev but on pypi.org.</p> <p>Important considerations</p> <ul> <li>Stability: PyPI packages might be less stable than their conda counterparts. Prefer using conda packages in the <code>dependencies</code> table where possible.</li> <li>Compatibility limitations: Currently, pixi doesn't support:<ul> <li><code>git</code> dependencies (<code>git+https://github.com/package-org/package.git</code>)</li> <li>Source dependencies</li> <li>Private PyPI repositories</li> </ul> </li> <li>Version specification: These dependencies don't follow the conda matchspec specification. The <code>version</code> is a <code>VersionSpecifier</code> and the <code>extras</code> are a list of <code>Strings</code>. So see the example below to see what type of definition is allowed.</li> </ul> <pre><code>[dependencies]\npython = \"&gt;=3.6\" # Python is needed for the pypi dependencies!\n\n[pypi-dependencies]\npytest = \"*\"  # This means any version (this `*` is custom in pixi)\npre-commit = \"~=3.5.0\" # Single string is of type VersionSpecifiers\nrequests = {version = \"&gt;= 2.8.1, ==2.8.*\", extras=[\"security\", \"tests\"]} # Using the map allows the user to add `extras`\n</code></pre> We use <code>rip</code> not <code>pip</code> <p>We use <code>rip</code> which is our custom pypi package resolver. The <code>rip</code> resolve step is invoked after the conda dependencies have been resolved. As the conda packages can also install python packages, which are used in the rip resolver. Also <code>rip</code> needs to know the version of python that is being used.</p>"},{"location":"configuration/#host-dependencies","title":"<code>host-dependencies</code>","text":"<p>This table contains dependencies that are needed to build your project but which should not be included when your project is installed as part of another project. In other words, these dependencies are available during the build but are no longer available when your project is installed. Dependencies listed in this table are installed for the architecture of the target machine.</p> <pre><code>[host-dependencies]\npython = \"~=3.10.3\"\n</code></pre> <p>Typical examples of host dependencies are:</p> <ul> <li>Base interpreters: a Python package would list <code>python</code> here and an R package would list <code>mro-base</code> or <code>r-base</code>.</li> <li>Libraries your project links against during compilation like <code>openssl</code>, <code>rapidjson</code>, or <code>xtensor</code>.</li> </ul>"},{"location":"configuration/#build-dependencies","title":"<code>build-dependencies</code>","text":"<p>This table contains dependencies that are needed to build the project. Different from <code>dependencies</code> and <code>host-dependencies</code> these packages are installed for the architecture of the build machine. This enables cross-compiling from one machine architecture to another.</p> <pre><code>[build-dependencies]\ncmake = \"~=3.24\"\n</code></pre> <p>Typical examples of build dependencies are:</p> <ul> <li>Compilers are invoked on the build machine, but they generate code for the target machine. If the project is cross-compiled, the architecture of the build and target machine might differ.</li> <li><code>cmake</code> is invoked on the build machine to generate additional code- or project-files which are then include in the compilation process.</li> </ul> <p>Info</p> <p>The build target refers to the machine that will execute the build. Programs and libraries installed by these dependencies will be executed on the build machine.</p> <p>For example, if you compile on a MacBook with an Apple Silicon chip but target Linux x86_64 then your build platform is <code>osx-arm64</code> and your host platform is <code>linux-64</code>.</p>"},{"location":"configuration/#the-activation-table","title":"The <code>activation</code> table","text":"<p>If you want to run an activation script inside the environment when either doing a <code>pixi run</code> or <code>pixi shell</code> these can be defined here. The scripts defined in this table will be sourced when the environment is activated using <code>pixi run</code> or <code>pixi shell</code></p> <p>Note</p> <p>The activation scripts are run by the system shell interpreter as they run before an environment is available. This means that it runs as <code>cmd.exe</code> on windows and <code>bash</code> on linux and osx (Unix). Only <code>.sh</code>, <code>.bash</code> and <code>.bat</code> files are supported.</p> <p>If you have scripts per platform use the target table.</p> <pre><code>[activation]\nscripts = [\"env_setup.sh\"]\n# To support windows platforms as well add the following\n[target.win-64.activation]\nscripts = [\"env_setup.bat\"]\n</code></pre>"},{"location":"configuration/#the-target-table","title":"The <code>target</code> table","text":"<p>The target table is a table that allows for platform specific configuration. Allowing you to make different sets of tasks or dependencies per platform.</p> <p>The target table is currently implemented for the following sub-tables:</p> <ul> <li><code>activation</code></li> <li><code>dependencies</code></li> <li><code>tasks</code></li> </ul> <p>The target table is defined using <code>[target.PLATFORM.SUB-TABLE]</code>. E.g <code>[target.linux-64.dependencies]</code></p> <p>The platform can be any of:</p> <ul> <li><code>win</code>, <code>osx</code>, <code>linux</code> or <code>unix</code> (<code>unix</code> matches <code>linux</code> and <code>osx</code>)</li> <li>or any of the (more) specific target platforms, e.g. <code>linux-64</code>, <code>osx-arm64</code></li> </ul> <p>The sub-table can be any of the specified above.</p> <p>To make it a bit more clear, let's look at an example below. Currently, pixi combines the top level tables like <code>dependencies</code> with the target-specific ones into a single set. Which, in the case of dependencies, can both add or overwrite dependencies. In the example below, we have <code>cmake</code> being used for all targets but on <code>osx-64</code> or <code>osx-arm64</code> a different version of python will be selected.</p> <pre><code>[dependencies]\ncmake = \"3.26.4\"\npython = \"3.10\"\n\n[target.osx.dependencies]\npython = \"3.11\"\n</code></pre> <p>Here are some more examples: <pre><code>[target.win-64.activation]\nscripts = [\"setup.bat\"]\n\n[target.win-64.dependencies]\nmsmpi = \"~=10.1.1\"\n\n[target.win-64.build-dependencies]\nvs2022_win-64 = \"19.36.32532\"\n\n[target.win-64.tasks]\ntmp = \"echo $TEMP\"\n\n[target.osx-64.dependencies]\nclang = \"&gt;=16.0.6\"\n</code></pre></p>"},{"location":"configuration/#the-feature-and-environments-tables","title":"The <code>feature</code> and <code>environments</code> tables","text":"<p>The <code>feature</code> table allows you to define features that can be used to create different <code>[environments]</code>. The <code>[environments]</code> table allows you to define different environments. The design is explained in the this design document.</p> <p>Simplest example<pre><code>[feature.test.dependencies]\npytest = \"*\"\n\n[environments]\ntest = [\"test\"]\n</code></pre> This will create an environment called <code>test</code> that has <code>pytest</code> installed.</p>"},{"location":"configuration/#the-feature-table","title":"The <code>feature</code> table","text":"<p>The <code>feature</code> table allows you to define the following fields per feature.</p> <ul> <li><code>dependencies</code>: Same as the dependencies.</li> <li><code>pypi-dependencies</code>: Same as the pypi-dependencies.</li> <li><code>system-requirements</code>: Same as the system-requirements.</li> <li><code>activation</code>: Same as the activation.</li> <li><code>platforms</code>: Same as the platforms. When adding features together the intersection of the platforms is taken. Be aware that the <code>default</code> feature is always implied thus this must contain all platforms the project can support.</li> <li><code>channels</code>: Same as the channels. Adding the <code>priority</code> field to the channels to allow concatenation of channels instead of overwriting.</li> <li><code>target</code>: Same as the target.</li> <li><code>tasks</code>: Same as the tasks.</li> </ul> <p>These tables are all also available without the <code>feature</code> prefix. When those are used we call them the <code>default</code> feature. This is a protected name you can not use for your own feature.</p> Full feature table specification<pre><code>[feature.cuda]\nactivation = {scripts = [\"cuda_activation.sh\"]}\nchannels = [\"nvidia\"] # Results in:  [\"nvidia\", \"conda-forge\"] when the default is `conda-forge`\ndependencies = {cuda = \"x.y.z\", cudnn = \"12.0\"}\npypi-dependencies = {torch = \"==1.9.0\"}\nplatforms = [\"linux-64\", \"osx-arm64\"]\nsystem-requirements = {cuda = \"12\"}\ntasks = { warmup = \"python warmup.py\" }\ntarget.osx-arm64 = {dependencies = {mlx = \"x.y.z\"}}\n</code></pre> Full feature table but written as separate tables<pre><code>[feature.cuda.activation]\nscripts = [\"cuda_activation.sh\"]\n\n[feature.cuda.dependencies]\ncuda = \"x.y.z\"\ncudnn = \"12.0\"\n\n[feature.cuda.pypi-dependencies]\ntorch = \"==1.9.0\"\n\n[feature.cuda.system-requirements]\ncuda = \"12\"\n\n[feature.cuda.tasks]\nwarmup = \"python warmup.py\"\n\n[feature.cuda.target.osx-arm64.dependencies]\nmlx = \"x.y.z\"\n\n# Channels and Platforms are not available as separate tables as they are implemented as lists\n[feature.cuda]\nchannels = [\"nvidia\"]\nplatforms = [\"linux-64\", \"osx-arm64\"]\n</code></pre>"},{"location":"configuration/#the-environments-table","title":"The <code>environments</code> table","text":"<p>The <code>environments</code> table allows you to define environments that are created using the features defined in the <code>feature</code> tables.</p> <p>Important</p> <p><code>default</code> is always implied when creating environments. If you don't want to use the <code>default</code> feature you can keep all the non feature tables empty.</p> <p>The environments table is defined using the following fields:</p> <ul> <li><code>features: Vec&lt;Feature&gt;</code>: The features that are included in the environment set, which is also the default field in the environments.</li> <li><code>solve-group: String</code>: The solve group is used to group environments together at the solve stage.   This is useful for environments that need to have the same dependencies but might extend them with additional dependencies.   For instance when testing a production environment with additional test dependencies.   These dependencies will then be the same version in all environments that have the same solve group.   But the different environments contain different subsets of the solve-groups dependencies set.</li> </ul> Simplest example<pre><code>[environments]\ntest = [\"test\"]\n</code></pre> Full environments table specification<pre><code>[environments]\ntest = {features = [\"test\"], solve-group = \"test\"}\nprod = {features = [\"prod\"], solve-group = \"test\"}\nlint = \"lint\"\n</code></pre>"},{"location":"environment/","title":"Environments","text":"<p>Pixi is a tool to manage virtual environments. This document explains what an environment looks like and how to use it.</p>"},{"location":"environment/#structure","title":"Structure","text":"<p>A pixi environment is located in the <code>.pixi/envs</code> directory of the project. This location is not configurable as it is a specific design decision to keep the environments in the project directory. This keeps your machine and your project clean and isolated from each other, and makes it easy to clean up after a project is done.</p> <p>If you look at the <code>.pixi/envs</code> directory, you will see a directory for each environment, the <code>default</code> being the one that is normally used, if you specify a custom environment the name you specified will be used.</p> <pre><code>.pixi\n\u2514\u2500\u2500 envs\n    \u251c\u2500\u2500 cuda\n    \u2502   \u251c\u2500\u2500 bin\n    \u2502   \u251c\u2500\u2500 conda-meta\n    \u2502   \u251c\u2500\u2500 etc\n    \u2502   \u251c\u2500\u2500 include\n    \u2502   \u251c\u2500\u2500 lib\n    \u2502   ...\n    \u2514\u2500\u2500 default\n        \u251c\u2500\u2500 bin\n        \u251c\u2500\u2500 conda-meta\n        \u251c\u2500\u2500 etc\n        \u251c\u2500\u2500 include\n        \u251c\u2500\u2500 lib\n        ...\n</code></pre> <p>These directories are conda environments, and you can use them as such, but you cannot manually edit them, this should always go through the <code>pixi.toml</code>. Pixi will always make sure the environment is in sync with the <code>pixi.lock</code> file. If this is not the case then all the commands that use the environment will automatically update the environment, e.g. <code>pixi run</code>, <code>pixi shell</code>.</p>"},{"location":"environment/#cleaning-up","title":"Cleaning up","text":"<p>If you want to clean up the environments, you can simply delete the <code>.pixi/envs</code> directory, and pixi will recreate the environments when needed. <pre><code># either:\nrm -rf .pixi/envs\n\n# or per environment:\nrm -rf .pixi/envs/default\nrm -rf .pixi/envs/cuda\n</code></pre></p>"},{"location":"environment/#activation","title":"Activation","text":"<p>An environment is nothing more than a set of files that are installed into a certain location, that somewhat mimics a global system install. You need to activate the environment to use it. In the most simple sense that mean adding the <code>bin</code> directory of the environment to the <code>PATH</code> variable. But there is more to it in a conda environment, as it also sets some environment variables.</p> <p>To do the activation we have multiple options: - Use the <code>pixi shell</code> command to open a shell with the environment activated. - Use the <code>pixi shell-hook</code> command to print the command to activate the environment in your current shell. - Use the <code>pixi run</code> command to run a command in the environment.</p> <p>Where the <code>run</code> command is special as it runs its own cross-platform shell and has the ability to run tasks. More information about tasks can be found in the tasks documentation.</p> <p>Using the <code>pixi shell-hook</code> in pixi you would get the following output: <pre><code>export PATH=\"/home/user/development/pixi/.pixi/envs/default/bin:/home/user/.local/bin:/home/user/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/home/user/.pixi/bin\"\nexport CONDA_PREFIX=\"/home/user/development/pixi/.pixi/envs/default\"\nexport PIXI_PROJECT_NAME=\"pixi\"\nexport PIXI_PROJECT_ROOT=\"/home/user/development/pixi\"\nexport PIXI_PROJECT_VERSION=\"0.12.0\"\nexport PIXI_PROJECT_MANIFEST=\"/home/user/development/pixi/pixi.toml\"\nexport CONDA_DEFAULT_ENV=\"pixi\"\nexport PIXI_ENVIRONMENT_PLATFORMS=\"osx-64,linux-64,win-64,osx-arm64\"\nexport PIXI_ENVIRONMENT_NAME=\"default\"\nexport PIXI_PROMPT=\"(pixi) \"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-binutils_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-gcc_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-gfortran_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/activate-gxx_linux-64.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/libglib_activate.sh\"\n. \"/home/user/development/pixi/.pixi/envs/default/etc/conda/activate.d/rust.sh\"\n</code></pre> It sets the <code>PATH</code> and some more environment variables. But more importantly it also runs activation scripts that are presented by the installed packages. An example of this would be the <code>libglib_activate.sh</code> script. Thus, just adding the <code>bin</code> directory to the <code>PATH</code> is not enough.</p>"},{"location":"environment/#environment-variables","title":"Environment variables","text":"<p>The following environment variables are set by pixi, when using the <code>pixi run</code>, <code>pixi shell</code>, or <code>pixi shell-hook</code> command:</p> <ul> <li><code>PIXI_PROJECT_ROOT</code>: The root directory of the project.</li> <li><code>PIXI_PROJECT_NAME</code>: The name of the project.</li> <li><code>PIXI_PROJECT_MANIFEST</code>: The path to the manifest file (<code>pixi.toml</code>).</li> <li><code>PIXI_PROJECT_VERSION</code>: The version of the project.</li> <li><code>PIXI_PROMPT</code>: The prompt to use in the shell, also used by <code>pixi shell</code> itself.</li> <li><code>PIXI_ENVIRONMENT_NAME</code>: The name of the environment, defaults to <code>default</code>.</li> <li><code>PIXI_ENVIRONMENT_PLATFORMS</code>: The path to the environment.</li> <li><code>CONDA_PREFIX</code>: The path to the environment. (Used by multiple tools that already understand conda environments)</li> <li><code>CONDA_DEFAULT_ENV</code>: The name of the environment. (Used by multiple tools that already understand conda environments)</li> <li><code>PATH</code>: We prepend the <code>bin</code> directory of the environment to the <code>PATH</code> variable, so you can use the tools installed in the environment directly.</li> </ul> <p>Note</p> <p>Even though the variables are environment variables these cannot be overridden. E.g. you can not change the root of the project by setting <code>PIXI_PROJECT_ROOT</code> in the environment.</p>"},{"location":"environment/#solving-environments","title":"Solving environments","text":"<p>When you run a command that uses the environment, pixi will check if the environment is in sync with the <code>pixi.lock</code> file. If it is not, pixi will solve the environment and update it. This means that pixi will retrieve the best set of packages for the dependency requirements that you specified in the <code>pixi.toml</code> and will put the output of the solve step into the <code>pixi.lock</code> file. Solving is a mathematical problem and can take some time, but we take pride in the way we solve environments, and we are confident that we can solve your environment in a reasonable time. If you want to learn more about the solving process, you can read these:</p> <ul> <li>Rattler(conda) resolver blog</li> <li>Rip(PyPI) resolver blog</li> </ul> <p>Pixi solves both the <code>conda</code> and <code>PyPI</code> dependencies, where the <code>PyPI</code> dependencies use the conda packages as a base, so you can be sure that the packages are compatible with each other. These solvers are split between the <code>rattler</code> and <code>rip</code> library, these control the heavy lifting of the solving process, which is executed by our custom SAT solver: <code>resolvo</code>. <code>resolve</code> is able to solve multiple ecosystem like <code>conda</code> and <code>PyPI</code>. It implements the lazy solving process for <code>PyPI</code> packages, which means that it only downloads the metadata of the packages that are needed to solve the environment. It also supports the <code>conda</code> way of solving, which means that it downloads the metadata of all the packages at once and then solves in one go.</p> <p>For the <code>[pypi-dependencies]</code>, <code>rip</code> implements <code>sdist</code> building to retrieve the metadata of the packages, and <code>wheel</code> building to install the packages. For this building step, <code>pixi</code> requires to first install <code>python</code> in the (conda)<code>[dependencies]</code> section of the <code>pixi.toml</code> file. This will always be slower than the pure conda solves. So for the best pixi experience you should stay within the <code>[dependencies]</code> section of the <code>pixi.toml</code> file.</p>"},{"location":"environment/#caching","title":"Caching","text":"<p>Pixi caches the packages used in the environment. So if you have multiple projects that use the same packages, pixi will only download the packages once.</p> <p>The cache is located in the <code>~/.cache/rattler/cache</code> directory by default. This location is configurable by setting the <code>PIXI_CACHE_DIR</code> or <code>RATTLER_CACHE_DIR</code> environment variable.</p> <p>When you want to clean the cache, you can simply delete the cache directory, and pixi will re-create the cache when needed.</p>"},{"location":"vision/","title":"Vision","text":"<p>We created <code>pixi</code> because we want to have a cargo/npm/yarn like package management experience for conda. We really love what the conda packaging ecosystem achieves, but we think that the user experience can be improved a lot. Modern package managers like <code>cargo</code> have shown us, how great a package manager can be. We want to bring that experience to the conda ecosystem.</p>"},{"location":"vision/#pixi-values","title":"Pixi values","text":"<p>We want to make pixi a great experience for everyone, so we have a few values that we want to uphold:</p> <ol> <li>Fast. We want to have a fast package manager, that is able to solve the environment in a few seconds.</li> <li>User Friendly. We want to have a package manager that puts user friendliness on the front-line. Providing easy, accessible and intuitive commands. That have the element of least surprise.</li> <li>Isolated Environment. We want to have isolated environments, that are reproducible and easy to share. Ideally, it should run on all common platforms. The Conda packaging system provides an excellent base for this.</li> <li>Single Tool. We want to integrate most common uses when working on a development project with Pixi, so it should support at least dependency management, command management, building and uploading packages. You should not need to reach to another external tool for this.</li> <li>Fun. It should be fun to use pixi and not cause frustrations, you should not need to think about it a lot and it should generally just get out of your way.</li> </ol>"},{"location":"vision/#conda","title":"Conda","text":"<p>We are building on top of the conda packaging ecosystem, this means that we have a huge number of packages available for different platforms on conda-forge. We believe the conda packaging ecosystem provides a solid base to manage your dependencies. Conda-forge is community maintained and very open to contributions. It is widely used in data science and scientific computing, robotics and other fields. And has a proven track record.</p>"},{"location":"vision/#target-languages","title":"Target languages","text":"<p>Essentially, we are language agnostics, we are targeting any language that can be installed with conda. Including: C++, Python, Rust, Zig etc. But we do believe the python ecosystem can benefit from a good package manager that is based on conda. So we are trying to provide an alternative to existing solutions there. We also think we can provide a good solution for C++ projects, as there are a lot of libraries available on conda-forge today. Pixi also truly shines when using it for multi-language projects e.g. a mix of C++ and Python, because we provide a nice way to build everything up to and including system level packages.</p>"},{"location":"advanced/advanced_tasks/","title":"Advanced tasks","text":"<p>When building a package, you often have to do more than just run the code. Steps like formatting, linting, compiling, testing, benchmarking, etc. are often part of a project. With pixi tasks, this should become much easier to do.</p> <p>Here are some quick examples</p> pixi.toml<pre><code>[tasks]\n# Commands as lists so you can also add documentation in between.\nconfigure = { cmd = [\n    \"cmake\",\n    # Use the cross-platform Ninja generator\n    \"-G\",\n    \"Ninja\",\n    # The source is in the root directory\n    \"-S\",\n    \".\",\n    # We wanna build in the .build directory\n    \"-B\",\n    \".build\",\n] }\n\n# Depend on other tasks\nbuild = { cmd = [\"ninja\", \"-C\", \".build\"], depends_on = [\"configure\"] }\n\n# Using environment variables\nrun = \"python main.py $PIXI_PROJECT_ROOT\"\nset = \"export VAR=hello &amp;&amp; echo $VAR\"\n\n# Cross platform file operations\ncopy = \"cp pixi.toml pixi_backup.toml\"\nclean = \"rm pixi_backup.toml\"\nmove = \"mv pixi.toml backup.toml\"\n</code></pre>"},{"location":"advanced/advanced_tasks/#depends-on","title":"Depends on","text":"<p>Just like packages can depend on other packages, our tasks can depend on other tasks. This allows for complete pipelines to be run with a single command.</p> <p>An obvious example is compiling before running an application.</p> <p>Checkout our <code>cpp_sdl</code> example for a running example. In that package we have some tasks that depend on each other, so we can assure that when you run <code>pixi run start</code> everything is set up as expected.</p> <pre><code>pixi task add configure \"cmake -G Ninja -S . -B .build\"\npixi task add build \"ninja -C .build\" --depends-on configure\npixi task add start \".build/bin/sdl_example\" --depends-on build\n</code></pre> <p>Results in the following lines added to the <code>pixi.toml</code></p> pixi.toml<pre><code>[tasks]\n# Configures CMake\nconfigure = \"cmake -G Ninja -S . -B .build\"\n# Build the executable but make sure CMake is configured first.\nbuild = { cmd = \"ninja -C .build\", depends_on = [\"configure\"] }\n# Start the built executable\nstart = { cmd = \".build/bin/sdl_example\", depends_on = [\"build\"] }\n</code></pre> <pre><code>pixi run start\n</code></pre> <p>The tasks will be executed after each other:</p> <ul> <li>First <code>configure</code> because it has no dependencies.</li> <li>Then <code>build</code> as it only depends on <code>configure</code>.</li> <li>Then <code>start</code> as all it dependencies are run.</li> </ul> <p>If one of the commands fails (exit with non-zero code.) it will stop and the next one will not be started.</p> <p>With this logic, you can also create aliases as you don't have to specify any command in a task.</p> <pre><code>pixi task add fmt ruff\npixi task add lint pylint\n</code></pre> <pre><code>pixi task alias style fmt lint\n</code></pre> <p>Results in the following <code>pixi.toml</code>.</p> pixi.toml<pre><code>fmt = \"ruff\"\nlint = \"pylint\"\nstyle = { depends_on = [\"fmt\", \"lint\"] }\n</code></pre> <p>Now run both tools with one command.</p> <pre><code>pixi run style\n</code></pre>"},{"location":"advanced/advanced_tasks/#working-directory","title":"Working directory","text":"<p>Pixi tasks support the definition of a working directory.</p> <p><code>cwd</code>\" stands for Current Working Directory. The directory is relative to the pixi package root, where the <code>pixi.toml</code> file is located.</p> <p>Consider a pixi project structured as follows: <pre><code>\u251c\u2500\u2500 pixi.toml\n\u2514\u2500\u2500 scripts\n    \u2514\u2500\u2500 bar.py\n</code></pre></p> <p>To add a task to run the <code>bar.py</code> file, use: <pre><code>pixi task add bar \"python bar.py\" --cwd scripts\n</code></pre></p> <p>This will add the following line to <code>pixi.toml</code>: pixi.toml<pre><code>[tasks]\nbar = { cmd = \"python bar.py\", cwd = \"scripts\" }\n</code></pre></p>"},{"location":"advanced/advanced_tasks/#our-task-runner-deno_task_shell","title":"Our task runner: deno_task_shell","text":"<p>To support the different OS's (Windows, OSX and Linux), pixi integrates a shell that can run on all of them. This is <code>deno_task_shell</code>. The task shell is a limited implementation of a bourne-shell interface.</p>"},{"location":"advanced/advanced_tasks/#built-in-commands","title":"Built-in commands","text":"<p>Next to running actual executable like <code>./myprogram</code>, <code>cmake</code> or <code>python</code> the shell has some built-in commandos.</p> <ul> <li><code>cp</code>: Copies files.</li> <li><code>mv</code>: Moves files.</li> <li><code>rm</code>: Remove files or directories.   Ex: <code>rm -rf [FILE]...</code> - Commonly used to recursively delete files or directories.</li> <li><code>mkdir</code>: Makes directories.   Ex. <code>mkdir -p DIRECTORY...</code> - Commonly used to make a directory and all its parents with no error if it exists.</li> <li><code>pwd</code>: Prints the name of the current/working directory.</li> <li><code>sleep</code>: Delays for a specified amount of time.   Ex. <code>sleep 1</code> to sleep for 1 second, <code>sleep 0.5</code> to sleep for half a second, or <code>sleep 1m</code> to sleep a minute</li> <li><code>echo</code>: Displays a line of text.</li> <li><code>cat</code>: Concatenates files and outputs them on stdout. When no arguments are provided, it reads and outputs stdin.</li> <li><code>exit</code>: Causes the shell to exit.</li> <li><code>unset</code>: Unsets environment variables.</li> <li><code>xargs</code>: Builds arguments from stdin and executes a command.</li> </ul>"},{"location":"advanced/advanced_tasks/#syntax","title":"Syntax","text":"<ul> <li>Boolean list: use <code>&amp;&amp;</code> or <code>||</code> to separate two commands.<ul> <li><code>&amp;&amp;</code>: if the command before <code>&amp;&amp;</code> succeeds continue with the next command.</li> <li><code>||</code>: if the command before <code>||</code> fails continue with the next command.</li> </ul> </li> <li>Sequential lists: use <code>;</code> to run two commands without checking if the first command failed or succeeded.</li> <li>Environment variables:<ul> <li>Set env variable using: <code>export ENV_VAR=value</code></li> <li>Use env variable using: <code>$ENV_VAR</code></li> <li>unset env variable using <code>unset ENV_VAR</code></li> </ul> </li> <li>Shell variables: Shell variables are similar to environment variables, but won\u2019t be exported to spawned commands.<ul> <li>Set them: <code>VAR=value</code></li> <li>use them: <code>VAR=value &amp;&amp; echo $VAR</code></li> </ul> </li> <li>Pipelines: Use the stdout output of a command into the stdin a following command<ul> <li><code>|</code>: <code>echo Hello | python receiving_app.py</code></li> <li><code>|&amp;</code>: use this to also get the stderr as input.</li> </ul> </li> <li>Command substitution: <code>$()</code> to use the output of a command as input for another command.<ul> <li><code>python main.py $(git rev-parse HEAD)</code></li> </ul> </li> <li>Negate exit code: <code>!</code> before any command will negate the exit code from 1 to 0 or visa-versa.</li> <li>Redirects: <code>&gt;</code> to redirect the stdout to a file.<ul> <li><code>echo hello &gt; file.txt</code> will put <code>hello</code> in <code>file.txt</code> and overwrite existing text.</li> <li><code>python main.py 2&gt; file.txt</code> will put the <code>stderr</code> output in <code>file.txt</code>.</li> <li><code>python main.py &amp;&gt; file.txt</code> will put the <code>stderr</code> and <code>stdout</code> in <code>file.txt</code>.</li> <li><code>echo hello &gt; file.txt</code> will append <code>hello</code> to the existing <code>file.txt</code>.</li> </ul> </li> <li>Glob expansion: <code>*</code> to expand all options.<ul> <li><code>echo *.py</code> will echo all filenames that end with <code>.py</code></li> <li><code>echo **/*.py</code> will echo all filenames that end with <code>.py</code> in this directory and all descendant directories.</li> <li><code>echo data[0-9].csv</code> will echo all filenames that have a single number after <code>data</code> and before <code>.csv</code></li> </ul> </li> </ul> <p>More info in <code>deno_task_shell</code> documentation.</p>"},{"location":"advanced/authentication/","title":"Authenticate pixi with a server","text":"<p>You can authenticate pixi with a server like prefix.dev, a private quetz instance or anaconda.org. Different servers use different authentication methods. In this documentation page, we detail how you can authenticate against the different servers and where the authentication information is stored.</p> <pre><code>Usage: pixi auth login [OPTIONS] &lt;HOST&gt;\n\nArguments:\n  &lt;HOST&gt;  The host to authenticate with (e.g. repo.prefix.dev)\n\nOptions:\n      --token &lt;TOKEN&gt;              The token to use (for authentication with prefix.dev)\n      --username &lt;USERNAME&gt;        The username to use (for basic HTTP authentication)\n      --password &lt;PASSWORD&gt;        The password to use (for basic HTTP authentication)\n      --conda-token &lt;CONDA_TOKEN&gt;  The token to use on anaconda.org / quetz authentication\n  -v, --verbose...                 More output per occurrence\n  -q, --quiet...                   Less output per occurrence\n  -h, --help                       Print help\n</code></pre> <p>The different options are \"token\", \"conda-token\" and \"username + password\".</p> <p>The token variant implements a standard \"Bearer Token\" authentication as is used on the prefix.dev platform. A Bearer Token is sent with every request as an additional header of the form <code>Authentication: Bearer &lt;TOKEN&gt;</code>.</p> <p>The conda-token option is used on anaconda.org and can be used with a quetz server. With this option, the token is sent as part of the URL following this scheme: <code>conda.anaconda.org/t/&lt;TOKEN&gt;/conda-forge/linux-64/...</code>.</p> <p>The last option, username &amp; password, are used for \"Basic HTTP Authentication\". This is the equivalent of adding <code>http://user:password@myserver.com/...</code>. This authentication method can be configured quite easily with a reverse NGinx or Apache server and is thus commonly used in self-hosted systems.</p>"},{"location":"advanced/authentication/#examples","title":"Examples","text":"<p>Login to prefix.dev:</p> <pre><code>pixi auth login prefix.dev --token pfx_jj8WDzvnuTEHGdAhwRZMC1Ag8gSto8\n</code></pre> <p>Login to anaconda.org:</p> <pre><code>pixi auth login anaconda.org --conda-token xy-72b914cc-c105-4ec7-a969-ab21d23480ed\n</code></pre> <p>Login to a basic HTTP secured server:</p> <pre><code>pixi auth login myserver.com --username user --password password\n</code></pre>"},{"location":"advanced/authentication/#where-does-pixi-store-the-authentication-information","title":"Where does pixi store the authentication information?","text":"<p>The storage location for the authentication information is system-dependent. By default, pixi tries to use the keychain to store this sensitive information securely on your machine.</p> <p>On Windows, the credentials are stored in the \"credentials manager\". Searching for <code>rattler</code> (the underlying library pixi uses) you should find any credentials stored by pixi (or other rattler-based programs).</p> <p>On macOS, the passwords are stored in the keychain. To access the password, you can use the <code>Keychain Access</code> program that comes pre-installed on macOS. Searching for <code>rattler</code> (the underlying library pixi uses) you should find any credentials stored by pixi (or other rattler-based programs).</p> <p>On Linux, one can use <code>GNOME Keyring</code> (or just Keyring) to access credentials that are securely stored by <code>libsecret</code>. Searching for <code>rattler</code> should list all the credentials stored by pixi and other rattler-based programs.</p>"},{"location":"advanced/authentication/#fallback-storage","title":"Fallback storage","text":"<p>If you run on a server with none of the aforementioned keychains available, then pixi falls back to store the credentials in an insecure JSON file. This JSON file is located at <code>~/.rattler/credentials.json</code> and contains the credentials.</p>"},{"location":"advanced/channel_priority/","title":"Channel Logic","text":"<p>All logic regarding the decision which dependencies can be installed from which channel is done by the instruction we give the solver.</p> <p>The actual code regarding this is in the <code>rattler_solve</code> crate. This might however be hard to read. Therefore, this document will continue with simplified flow charts.</p>"},{"location":"advanced/channel_priority/#channel-specific-dependencies","title":"Channel specific dependencies","text":"<p>When a user defines a channel per dependency, the solver needs to know the other channels are unusable for this dependency. <pre><code>[project]\nchannels = [\"conda-forge\", \"my-channel\"]\n\n[dependencies]\npackgex = { version = \"*\", channel = \"my-channel\" }\n</code></pre> In the <code>packagex</code> example, the solver will understand that the package is only available in <code>my-channel</code> and will not look for it in <code>conda-forge</code>.</p> <p>The flowchart of the logic that excludes all other channels:</p> <pre><code>flowchart TD\n    A[Start] --&gt; B[Given a Dependency]\n    B --&gt; C{Channel Specific Dependency?}\n    C --&gt;|Yes| D[Exclude All Other Channels for This Package]\n    C --&gt;|No| E{Any Other Dependencies?}\n    E --&gt;|Yes| B\n    E --&gt;|No| F[End]\n    D --&gt; E</code></pre>"},{"location":"advanced/channel_priority/#channel-priority","title":"Channel priority","text":"<p>Channel priority is dictated by the order in the <code>project.channels</code> array, where the first channel is the highest priority. For instance: <pre><code>[project]\nchannels = [\"conda-forge\", \"my-channel\", \"your-channel\"]\n</code></pre> If the package is found in <code>conda-forge</code> the solver will not look for it in <code>my-channel</code> and <code>your-channel</code>, because it tells the solver they are excluded. If the package is not found in <code>conda-forge</code> the solver will look for it in <code>my-channel</code> and if it is found there it will tell the solver to exclude <code>your-channel</code> for this package. This diagram explains the logic: <pre><code>flowchart TD\n    A[Start] --&gt; B[Given a Dependency]\n    B --&gt; C{Loop Over Channels}\n    C --&gt; D{Package in This Channel?}\n    D --&gt;|No| C\n    D --&gt;|Yes| E{\"This the first channel\n     for this package?\"}\n    E --&gt;|Yes| F[Include Package in Candidates]\n    E --&gt;|No| G[Exclude Package from Candidates]\n    F --&gt; H{Any Other Channels?}\n    G --&gt; H\n    H --&gt;|Yes| C\n    H --&gt;|No| I{Any Other Dependencies?}\n    I --&gt;|No| J[End]\n    I --&gt;|Yes| B</code></pre></p> <p>This method ensures the solver only adds a package to the candidates if it's found in the highest priority channel available. If you have 10 channels and the package is found in the 5th channel it will exclude the next 5 channels from the candidates if they also contain the package.</p>"},{"location":"advanced/channel_priority/#use-case-pytorch-and-nvidia-with-conda-forge","title":"Use case: pytorch and nvidia with conda-forge","text":"<p>A common use case is to use <code>pytorch</code> with <code>nvidia</code> drivers, while also needing the <code>conda-forge</code> channel for the main dependencies. <pre><code>[project]\nchannels = [\"nvidia/label/cuda-11.8.0\", \"nvidia\", \"conda-forge\", \"pytorch\"]\nplatforms = [\"linux-64\"]\n\n[dependencies]\ncuda = {version = \"*\", channel=\"nvidia/label/cuda-11.8.0\"}\npytorch = {version = \"2.0.1.*\", channel=\"pytorch\"}\ntorchvision = {version = \"0.15.2.*\", channel=\"pytorch\"}\npytorch-cuda = {version = \"11.8.*\", channel=\"pytorch\"}\npython = \"3.10.*\"\n</code></pre> What this will do is get as much as possible from the <code>nvidia/label/cuda-11.8.0</code> channel, which is actually only the <code>cuda</code> package.</p> <p>Then it will get all packages from the <code>nvidia</code> channel, which is a little more and some packages overlap the <code>nvidia</code> and <code>conda-forge</code> channel. Like the <code>cuda-cudart</code> package, which will now only be retrieved from the <code>nvidia</code> channel because of the priority logic.</p> <p>Then it will get the packages from the <code>conda-forge</code> channel, which is the main channel for the dependencies.</p> <p>But the user only wants the pytorch packages from the <code>pytorch</code> channel, which is why <code>pytorch</code> is added last and the dependencies are added as channel specific dependencies.</p> <p>We don't define the <code>pytorch</code> channel before <code>conda-forge</code> because we want to get as much as possible from the <code>conda-forge</code> as the pytorch channel is not always shipping the best versions of all packages.</p> <p>For example, it also ships the <code>ffmpeg</code> package, but only an old version which doesn't work with the newer pytorch versions. Thus breaking the installation if we would skip the <code>conda-forge</code> channel for <code>ffmpeg</code> with the priority logic.</p>"},{"location":"advanced/explain_info_command/","title":"Info command","text":"<p><code>pixi info</code> prints out useful information to debug a situation or to get an overview of your machine/project. This information can also be retrieved in <code>json</code> format using the <code>--json</code> flag, which can be useful for programmatically reading it.</p> Running pixi info in the pixi repo<pre><code>\u279c pixi info\n      Pixi version: 0.13.0\n          Platform: linux-64\n  Virtual packages: __unix=0=0\n                  : __linux=6.5.12=0\n                  : __glibc=2.36=0\n                  : __cuda=12.3=0\n                  : __archspec=1=x86_64\n         Cache dir: /home/user/.cache/rattler/cache\n      Auth storage: /home/user/.rattler/credentials.json\n\nProject\n------------\n           Version: 0.13.0\n     Manifest file: /home/user/development/pixi/pixi.toml\n      Last updated: 25-01-2024 10:29:08\n\nEnvironments\n------------\ndefault\n          Features: default\n          Channels: conda-forge\n  Dependency count: 10\n      Dependencies: pre-commit, rust, openssl, pkg-config, git, mkdocs, mkdocs-material, pillow, cairosvg, compilers\n  Target platforms: linux-64, osx-arm64, win-64, osx-64\n             Tasks: docs, test-all, test, build, lint, install, build-docs\n</code></pre>"},{"location":"advanced/explain_info_command/#global-info","title":"Global info","text":"<p>The first part of the info output is information that is always available and tells you what pixi can read on your machine.</p>"},{"location":"advanced/explain_info_command/#platform","title":"Platform","text":"<p>This defines the platform you're currently on according to pixi. If this is incorrect, please file an issue on the pixi repo.</p>"},{"location":"advanced/explain_info_command/#virtual-packages","title":"Virtual packages","text":"<p>The virtual packages that pixi can find on your machine.</p> <p>In the Conda ecosystem, you can depend on virtual packages. These packages aren't real dependencies that are going to be installed, but rather are being used in the solve step to find if a package can be installed on the machine. A simple example: When a package depends on Cuda drivers being present on the host machine it can do that by depending on the <code>__cuda</code> virtual package. In that case, if pixi cannot find the <code>__cuda</code> virtual package on your machine the installation will fail.</p>"},{"location":"advanced/explain_info_command/#cache-dir","title":"Cache dir","text":"<p>Pixi caches all previously downloaded packages in a cache folder. This cache folder is shared between all pixi projects and globally installed tools. Normally the locations would be:</p> Platform Value Linux <code>$XDG_CACHE_HOME/rattler</code> or <code>$HOME</code>/.cache/rattler macOS <code>$HOME</code>/Library/Caches/rattler Windows <code>{FOLDERID_LocalAppData}/rattler</code> <p>When your system is filling up you can easily remove this folder. It will re-download everything it needs the next time you install a project.</p>"},{"location":"advanced/explain_info_command/#auth-storage","title":"Auth storage","text":"<p>Check the authentication documentation</p>"},{"location":"advanced/explain_info_command/#cache-size","title":"Cache size","text":"<p>[requires <code>--extended</code>]</p> <p>The size of the previously mentioned \"Cache dir\" in Mebibytes.</p>"},{"location":"advanced/explain_info_command/#project-info","title":"Project info","text":"<p>Everything below <code>Project</code> is info about the project you're currently in. This info is only available if your path has a manifest file (<code>pixi.toml</code>).</p>"},{"location":"advanced/explain_info_command/#manifest-file","title":"Manifest file","text":"<p>The path to the manifest file that describes the project. For now, this can only be <code>pixi.toml</code>.</p>"},{"location":"advanced/explain_info_command/#last-updated","title":"Last updated","text":"<p>The last time the lockfile was updated, either manually or by pixi itself.</p>"},{"location":"advanced/explain_info_command/#environment-info","title":"Environment info","text":"<p>The environment info defined per environment. If you don't have any environments defined, this will only show the <code>default</code> environment.</p>"},{"location":"advanced/explain_info_command/#features","title":"Features","text":"<p>This lists which features are enabled in the environment. For the default this is only <code>default</code></p>"},{"location":"advanced/explain_info_command/#channels","title":"Channels","text":"<p>The list of channels used in this environment.</p>"},{"location":"advanced/explain_info_command/#dependency-count","title":"Dependency count","text":"<p>The amount of dependencies defined that are defined for this environment (not the amount of installed dependencies).</p>"},{"location":"advanced/explain_info_command/#dependencies","title":"Dependencies","text":"<p>The list of dependencies defined for this environment.</p>"},{"location":"advanced/explain_info_command/#target-platforms","title":"Target platforms","text":"<p>The platforms the project has defined.</p>"},{"location":"advanced/multi_platform_configuration/","title":"Multi platform config","text":"<p>Pixi's vision includes being supported on all major platforms. Sometimes that needs some extra configuration to work well. On this page, you will learn what you can configure to align better with the platform you are making your application for.</p> <p>Here is an example <code>pixi.toml</code> that highlights some of the features:</p> pixi.toml<pre><code>[project]\n# Default project info....\n# A list of platforms you are supporting with your package.\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[dependencies]\npython = \"&gt;=3.8\"\n\n[target.win-64.dependencies]\n# Overwrite the needed python version only on win-64\npython = \"3.7\"\n\n\n[activation]\nscripts = [\"setup.sh\"]\n\n[target.win-64.activation]\n# Overwrite activation scripts only for windows\nscripts = [\"setup.bat\"]\n</code></pre>"},{"location":"advanced/multi_platform_configuration/#platform-definition","title":"Platform definition","text":"<p>The <code>project.platforms</code> defines which platforms your project supports. When multiple platforms are defined, pixi determines which dependencies to install for each platform individually. All of this is stored in a lockfile.</p> <p>Running <code>pixi install</code> on a platform that is not configured will warn the user that it is not setup for that platform:</p> <pre><code>\u276f pixi install\n  \u00d7 the project is not configured for your current platform\n   \u256d\u2500[pixi.toml:6:1]\n 6 \u2502 channels = [\"conda-forge\"]\n 7 \u2502 platforms = [\"osx-64\", \"osx-arm64\", \"win-64\"]\n   \u00b7             \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   \u00b7                             \u2570\u2500\u2500 add 'linux-64' here\n 8 \u2502\n   \u2570\u2500\u2500\u2500\u2500\n  help: The project needs to be configured to support your platform (linux-64).\n</code></pre>"},{"location":"advanced/multi_platform_configuration/#target-specifier","title":"Target specifier","text":"<p>With the target specifier, you can overwrite the original configuration specifically for a single platform. If you are targeting a specific platform in your target specifier that was not specified in your <code>project.platforms</code> then pixi will throw an error.</p>"},{"location":"advanced/multi_platform_configuration/#dependencies","title":"Dependencies","text":"<p>It might happen that you want to install a certain dependency only on a specific platform, or you might want to use a different version on different platforms.</p> pixi.toml<pre><code>[dependencies]\npython = \"&gt;=3.8\"\n\n[target.win-64.dependencies]\nmsmpi = \"*\"\npython = \"3.8\"\n</code></pre> <p>In the above example, we specify that we depend on <code>msmpi</code> only on Windows. We also specifically want <code>python</code> on <code>3.8</code> when installing on Windows. This will overwrite the dependencies from the generic set of dependencies. This will not touch any of the other platforms.</p> <p>You can use pixi's cli to add these dependencies to the <code>pixi.toml</code></p> <pre><code>pixi add --platform win-64 posix\n</code></pre> <p>This also works for the <code>host</code> and <code>build</code> dependencies.</p> <pre><code>pixi add --host --platform win-64 posix\npixi add --build --platform osx-64 clang\n</code></pre> <p>Which results in this.</p> pixi.toml<pre><code>[target.win-64.host-dependencies]\nposix = \"1.0.0.*\"\n\n[target.osx-64.build-dependencies]\nclang = \"16.0.6.*\"\n</code></pre>"},{"location":"advanced/multi_platform_configuration/#activation","title":"Activation","text":"<p>Pixi's vision is to enable completely cross-platform projects, but you often need to run tools that are not built by your projects. Generated activation scripts are often in this category, default scripts in unix are <code>bash</code> and for windows they are <code>bat</code></p> <p>To deal with this, you can define your activation scripts using the target definition.</p> <p>pixi.toml<pre><code>[activation]\nscripts = [\"setup.sh\", \"local_setup.bash\"]\n\n[target.win-64.activation]\nscripts = [\"setup.bat\", \"local_setup.bat\"]\n</code></pre> When this project is run on <code>win-64</code> it will only execute the target scripts not the scripts specified in the default <code>activation.scripts</code></p>"},{"location":"design_proposals/multi_environment_proposal/","title":"Proposal Design: Multi Environment Support","text":""},{"location":"design_proposals/multi_environment_proposal/#objective","title":"Objective","text":"<p>The aim is to introduce an environment set mechanism in the <code>pixi</code> package manager. This mechanism will enable clear, conflict-free management of dependencies tailored to specific environments, while also maintaining the integrity of fixed lockfiles.</p>"},{"location":"design_proposals/multi_environment_proposal/#motivating-example","title":"Motivating Example","text":"<p>There are multiple scenarios where multiple environments are useful.</p> <ul> <li>Testing of multiple package versions, e.g. <code>py39</code> and <code>py310</code> or polars <code>0.12</code> and <code>0.13</code>.</li> <li>Smaller single tool environments, e.g. <code>lint</code> or <code>docs</code>.</li> <li>Large developer environments, that combine all the smaller environments, e.g. <code>dev</code>.</li> <li>Strict supersets of environments, e.g. <code>prod</code> and <code>test-prod</code> where <code>test-prod</code> is a strict superset of <code>prod</code>.</li> <li>Multiple machines from one project, e.g. a <code>cuda</code> environment and a <code>cpu</code> environment.</li> <li>And many more. (Feel free to edit this document in our GitHub and add your use case.)</li> </ul> <p>This prepares <code>pixi</code> for use in large projects with multiple use-cases, multiple developers and different CI needs.</p>"},{"location":"design_proposals/multi_environment_proposal/#design-considerations","title":"Design Considerations","text":"<ol> <li>User-friendliness: Pixi is a user focussed tool that goes beyond developers. The feature should have good error reporting and helpful documentation from the start.</li> <li>Keep it simple: Not understanding the multiple environments feature shouldn't limit a user to use pixi. The feature should be \"invisible\" to the non-multi env use-cases.</li> <li>No Automatic Combinatorial: To ensure the dependency resolution process remains manageable, the solution should avoid a combinatorial explosion of dependency sets. By making the environments user defined and not automatically inferred by testing a matrix of the features.</li> <li>Single environment Activation: The design should allow only one environment to be active at any given time, simplifying the resolution process and preventing conflicts.</li> <li>Fixed Lockfiles: It's crucial to preserve fixed lockfiles for consistency and predictability. Solutions must ensure reliability not just for authors but also for end-users, particularly at the time of lockfile creation.</li> </ol>"},{"location":"design_proposals/multi_environment_proposal/#proposed-solution","title":"Proposed Solution","text":"<p>Important</p> <p>This is a proposal, not a final design. The proposal is open for discussion and will be updated based on the feedback.</p>"},{"location":"design_proposals/multi_environment_proposal/#feature-environment-set-definitions","title":"Feature &amp; Environment Set Definitions","text":"<p>Introduce environment sets into the <code>pixi.toml</code> this describes environments based on <code>feature</code>'s. Introduce features into the <code>pixi.toml</code> that can describe parts of environments. As an environment goes beyond just <code>dependencies</code> the <code>features</code> should be described including the following fields:</p> <ul> <li><code>dependencies</code>: The conda package dependencies</li> <li><code>pypi-dependencies</code>: The pypi package dependencies</li> <li><code>system-requirements</code>: The system requirements of the environment</li> <li><code>activation</code>: The activation information for the environment</li> <li><code>platforms</code>: The platforms the environment can be run on.</li> <li><code>channels</code>: The channels used to create the environment. Adding the <code>priority</code> field to the channels to allow concatenation of channels instead of overwriting.</li> <li><code>target</code>: All the above features but also separated by targets.</li> <li><code>tasks</code>: Feature specific tasks, tasks in one environment are selected as default tasks for the environment.</li> </ul> Default features<pre><code>[dependencies] # short for [feature.default.dependencies]\npython = \"*\"\nnumpy = \"==2.3\"\n\n[pypi-dependencies] # short for [feature.default.pypi-dependencies]\npandas = \"*\"\n\n[system-requirements] # short for [feature.default.system-requirements]\nlibc = \"2.33\"\n\n[activation] # short for [feature.default.activation]\nscripts = [\"activate.sh\"]\n</code></pre> Different dependencies per feature<pre><code>[feature.py39.dependencies]\npython = \"~=3.9.0\"\n[feature.py310.dependencies]\npython = \"~=3.10.0\"\n[feature.test.dependencies]\npytest = \"*\"\n</code></pre> Full set of environment modification in one feature<pre><code>[feature.cuda]\ndependencies = {cuda = \"x.y.z\", cudnn = \"12.0\"}\npypi-dependencies = {torch = \"1.9.0\"}\nplatforms = [\"linux-64\", \"osx-arm64\"]\nactivation = {scripts = [\"cuda_activation.sh\"]}\nsystem-requirements = {cuda = \"12\"}\n# Channels concatenate using a priority instead of overwrite, so the default channels are still used.\n# Using the priority the concatenation is controlled, default is 0, the default channels are used last.\n# Highest priority comes first.\nchannels = [\"nvidia\", {channel = \"pytorch\", priority = \"-1\"}] # Results in:  [\"nvidia\", \"conda-forge\", \"pytorch\"] when the default is `conda-forge`\ntasks = { warmup = \"python warmup.py\" }\ntarget.osx-arm64 = {dependencies = {mlx = \"x.y.z\"}}\n</code></pre> Define tasks as defaults of an environment<pre><code>[feature.test.tasks]\ntest = \"pytest\"\n\n[environments]\ntest = [\"test\"]\n\n# `pixi run test` == `pixi run --environments test test`\n</code></pre> <p>The environment definition should contain the following fields:</p> <ul> <li><code>features: Vec&lt;Feature&gt;</code>: The features that are included in the environment set, which is also the default field in the environments.</li> <li><code>solve-group: String</code>: The solve group is used to group environments together at the solve stage. This is useful for environments that need to have the same dependencies but might extend them with additional dependencies. For instance when testing a production environment with additional test dependencies.</li> </ul> Creating environments from features<pre><code>[environments]\n# implicit: default = [\"default\"]\ndefault = [\"py39\"] # implicit: default = [\"py39\", \"default\"]\npy310 = [\"py310\"] # implicit: py310 = [\"py310\", \"default\"]\ntest = [\"test\"] # implicit: test = [\"test\", \"default\"]\ntest39 = [\"test\", \"py39\"] # implicit: test39 = [\"test\", \"py39\", \"default\"]\n</code></pre> Testing a production environment with additional dependencies<pre><code>[environments]\n# Creating a `prod` environment which is the minimal set of dependencies used for production.\nprod = {features = [\"py39\"], solve-group = \"prod\"}\n# Creating a `test_prod` environment which is the `prod` environment plus the `test` feature.\ntest_prod = {features = [\"py39\", \"test\"], solve-group = \"prod\"}\n# Using the `solve-group` to solve the `prod` and `test_prod` environments together\n# Which makes sure the tested environment has the same version of the dependencies as the production environment.\n</code></pre> Creating environments without a default environment<pre><code>[dependencies]\n# Keep empty or undefined to create an empty environment.\n\n[feature.base.dependencies]\npython = \"*\"\n\n[feature.lint.dependencies]\npre-commit = \"*\"\n\n[environments]\n# Create a custom default\ndefault = [\"base\"]\n# Create a custom environment which only has the `lint` feature as the default feature is empty.\nlint = [\"lint\"]\n</code></pre>"},{"location":"design_proposals/multi_environment_proposal/#lockfile-structure","title":"Lockfile Structure","text":"<p>Within the <code>pixi.lock</code> file, a package may now include an additional <code>environments</code> field, specifying the environment to which it belongs. To avoid duplication the packages <code>environments</code> field may contain multiple environments so the lockfile is of minimal size. <pre><code>- platform: linux-64\n  name: pre-commit\n  version: 3.3.3\n  category: main\n  environments:\n    - dev\n    - test\n    - lint\n  ...:\n- platform: linux-64\n  name: python\n  version: 3.9.3\n  category: main\n  environments:\n    - dev\n    - test\n    - lint\n    - py39\n    - default\n  ...:\n</code></pre></p>"},{"location":"design_proposals/multi_environment_proposal/#user-interface-environment-activation","title":"User Interface Environment Activation","text":"<p>Users can manually activate the desired environment via command line or configuration. This approach guarantees a conflict-free environment by allowing only one feature set to be active at a time. For the user the cli would look like this:</p> Default behavior<pre><code>pixi run python\n# Runs python in the `default` environment\n</code></pre> Activating an specific environment<pre><code>pixi run -e test pytest\npixi run --environment test pytest\n# Runs `pytest` in the `test` environment\n</code></pre> <p>Activating a shell in an environment<pre><code>pixi shell -e cuda\npixi shell --environment cuda\n# Starts a shell in the `cuda` environment\n</code></pre> Running any command in an environment<pre><code>pixi run -e test any_command\n# Runs any_command in the `test` environment which doesn't require to be predefined as a task.\n</code></pre></p> Interactive selection of environments if task is in multiple environments<pre><code># In the scenario where test is a task in multiple environments, interactive selection should be used.\npixi run test\n# Which env?\n# 1. test\n# 2. test39\n</code></pre>"},{"location":"design_proposals/multi_environment_proposal/#important-links","title":"Important links","text":"<ul> <li>Initial writeup of the proposal: GitHub Gist by 0xbe7a</li> <li>GitHub project: #10</li> </ul>"},{"location":"design_proposals/multi_environment_proposal/#real-world-example-use-cases","title":"Real world example use cases","text":"Polarify test setup <p>In <code>polarify</code> they want to test multiple versions combined with multiple versions of polars. This is currently done by using a matrix in GitHub actions. This can be replaced by using multiple environments.</p> pixi.toml<pre><code>[project]\nname = \"polarify\"\n# ...\nchannels = [\"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"]\n\n[tasks]\npostinstall = \"pip install --no-build-isolation --no-deps --disable-pip-version-check -e .\"\n\n[dependencies]\npython = \"&gt;=3.9\"\npip = \"*\"\npolars = \"&gt;=0.14.24,&lt;0.21\"\n\n[feature.py39.dependencies]\npython = \"3.9.*\"\n[feature.py310.dependencies]\npython = \"3.10.*\"\n[feature.py311.dependencies]\npython = \"3.11.*\"\n[feature.py312.dependencies]\npython = \"3.12.*\"\n[feature.pl017.dependencies]\npolars = \"0.17.*\"\n[feature.pl018.dependencies]\npolars = \"0.18.*\"\n[feature.pl019.dependencies]\npolars = \"0.19.*\"\n[feature.pl020.dependencies]\npolars = \"0.20.*\"\n\n[feature.test.dependencies]\npytest = \"*\"\npytest-md = \"*\"\npytest-emoji = \"*\"\nhypothesis = \"*\"\n[feature.test.tasks]\ntest = \"pytest\"\n\n[feature.lint.dependencies]\npre-commit = \"*\"\n[feature.lint.tasks]\nlint = \"pre-commit run --all\"\n\n[environments]\npl017 = [\"pl017\", \"py39\", \"test\"]\npl018 = [\"pl018\", \"py39\", \"test\"]\npl019 = [\"pl019\", \"py39\", \"test\"]\npl020 = [\"pl020\", \"py39\", \"test\"]\npy39 = [\"py39\", \"test\"]\npy310 = [\"py310\", \"test\"]\npy311 = [\"py311\", \"test\"]\npy312 = [\"py312\", \"test\"]\n</code></pre> .github/workflows/test.yml<pre><code>jobs:\n  tests:\n  name: Test ${{ matrix.environment }}\n  runs-on: ubuntu-latest\n  strategy:\n    matrix:\n      environment:\n        - pl017\n        - pl018\n        - pl019\n        - pl020\n        - py39\n        - py310\n        - py311\n        - py312\n  steps:\n    - uses: actions/checkout@v4\n    - uses: prefix-dev/setup-pixi@v0.5.0\n      with:\n        # already installs the corresponding environment and caches it\n        environments: ${{ matrix.environment }}\n    - name: Install dependencies\n      run: |\n        pixi run --env ${{ matrix.environment }} postinstall\n        pixi run --env ${{ matrix.environment }} test\n</code></pre> Test vs Production example <p>This is an example of a project that has a <code>test</code> feature and <code>prod</code> environment. The <code>prod</code> environment is a production environment that contains the run dependencies. The <code>test</code> feature is a set of dependencies and tasks that we want to put on top of the previously solved <code>prod</code> environment. This is a common use case where we want to test the production environment with additional dependencies.</p> <p>pixi.toml<pre><code>[project]\nname = \"my-app\"\n# ...\nchannels = [\"conda-forge\"]\nplatforms = [\"osx-arm64\", \"linux-64\"]\n\n[tasks]\npostinstall-e = \"pip install --no-build-isolation --no-deps --disable-pip-version-check -e .\"\npostinstall = \"pip install --no-build-isolation --no-deps --disable-pip-version-check .\"\ndev = \"uvicorn my_app.app:main --reload\"\nserve = \"uvicorn my_app.app:main\"\n\n[dependencies]\npython = \"&gt;=3.12\"\npip = \"*\"\npydantic = \"&gt;=2\"\nfastapi = \"&gt;=0.105.0\"\nsqlalchemy = \"&gt;=2,&lt;3\"\nuvicorn = \"*\"\naiofiles = \"*\"\n\n[feature.test.dependencies]\npytest = \"*\"\npytest-md = \"*\"\npytest-asyncio = \"*\"\n[feature.test.tasks]\ntest = \"pytest --md=report.md\"\n\n[environments]\n# both default and prod will have exactly the same dependency versions when they share a dependency\ndefault = {features = [\"test\"], solve-group = \"prod-group\"}\nprod = {features = [], solve-group = \"prod-group\"}\n</code></pre> In ci you would run the following commands: <pre><code>pixi run postinstall-e &amp;&amp; pixi run test\n</code></pre> Locally you would run the following command: <pre><code>pixi run postinstall-e &amp;&amp; pixi run dev\n</code></pre></p> <p>Then in a Dockerfile you would run the following command: Dockerfile<pre><code>FROM ghcr.io/prefix-dev/pixi:latest # this doesn't exist yet\nWORKDIR /app\nCOPY . .\nRUN pixi run --env prod postinstall\nEXPOSE 8080\nCMD [\"/usr/local/bin/pixi\", \"run\", \"--env\", \"prod\", \"serve\"]\n</code></pre></p> Multiple machines from one project <p>This is an example for an ML project that should be executable on a machine that supports <code>cuda</code> and <code>mlx</code>. It should also be executable on machines that don't support <code>cuda</code> or <code>mlx</code>, we use the <code>cpu</code> feature for this. pixi.toml<pre><code>[project]\nname = \"my-ml-project\"\ndescription = \"A project that does ML stuff\"\nauthors = [\"Your Name &lt;your.name@gmail.com&gt;\"]\nchannels = [\"conda-forge\", \"pytorch\"]\n# All platforms that are supported by the project as the features will take the intersection of the platforms defined there.\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[tasks]\ntrain-model = \"python train.py\"\nevaluate-model = \"python test.py\"\n\n[dependencies]\npython = \"3.11.*\"\npytorch = {version = \"&gt;=2.0.1\", channel = \"pytorch\"}\ntorchvision = {version = \"&gt;=0.15\", channel = \"pytorch\"}\npolars = \"&gt;=0.20,&lt;0.21\"\nmatplotlib-base = \"&gt;=3.8.2,&lt;3.9\"\nipykernel = \"&gt;=6.28.0,&lt;6.29\"\n\n[feature.cuda]\nplatforms = [\"win-64\", \"linux-64\"]\nchannels = [\"nvidia\", {channel = \"pytorch\", priority = \"-1\"}]\nsystem-requirements = {cuda = \"12.1\"}\n\n[feature.cuda.tasks]\ntrain-model = \"python train.py --cuda\"\nevaluate-model = \"python test.py --cuda\"\n\n[feature.cuda.dependencies]\npytorch-cuda = {version = \"12.1.*\", channel = \"pytorch\"}\n\n[feature.mlx]\nplatforms = [\"osx-arm64\"]\n\n[feature.mlx.tasks]\ntrain-model = \"python train.py --mlx\"\nevaluate-model = \"python test.py --mlx\"\n\n[feature.mlx.dependencies]\nmlx = \"&gt;=0.5.0,&lt;0.6.0\"\n\n[feature.cpu]\nplatforms = [\"win-64\", \"linux-64\", \"osx-64\", \"osx-arm64\"]\n\n[environments]\ncuda = [\"cuda\"]\nmlx = [\"mlx\"]\ndefault = [\"cpu\"]\n</code></pre></p> Running the project on a cuda machine<pre><code>pixi run train-model --env cuda\n# will execute `python train.py --cuda`\n# fails if not on linux-64 or win-64 with cuda 12.1\n</code></pre> Running the project with mlx<pre><code>pixi run train-model --env mlx\n# will execute `python train.py --mlx`\n# fails if not on osx-arm64\n</code></pre> Running the project on a machine without cuda or mlx<pre><code>pixi run train-model\n</code></pre>"},{"location":"examples/cpp-sdl/","title":"SDL example","text":"<p> The <code>cpp-sdl</code> example is located in the pixi repository.</p> <pre><code>git clone https://github.com/prefix-dev/pixi.git\n</code></pre> <p>Move to the example folder</p> <pre><code>cd pixi/examples/cpp-sdl\n</code></pre> <p>Run the <code>start</code> command</p> <pre><code>pixi run start\n</code></pre> <p>Using the <code>depends_on</code> feature you only needed to run the <code>start</code> task but under water it is running the following tasks.</p> <pre><code># Configure the CMake project\npixi run configure\n\n# Build the executable\npixi run build\n\n# Start the build executable\npixi run start\n</code></pre>"},{"location":"examples/opencv/","title":"Opencv example","text":"<p>The <code>opencv</code> example is located in the pixi repository.</p> <pre><code>git clone https://github.com/prefix-dev/pixi.git\n</code></pre> <p>Move to the example folder</p> <pre><code>cd pixi/examples/opencv\n</code></pre>"},{"location":"examples/opencv/#face-detection","title":"Face detection","text":"<p>Run the <code>start</code> command to start the face detection algorithm.</p> <pre><code>pixi run start\n</code></pre> <p>The screen that starts should look like this: </p> <p>Check out the <code>webcame_capture.py</code> to see how we detect a face.</p>"},{"location":"examples/opencv/#camera-calibration","title":"Camera Calibration","text":"<p>Next to face recognition, a camera calibration example is also included.</p> <p>You'll need a checkerboard for this to work. Print this: </p> <p>Then run</p> <pre><code>pixi run calibrate\n</code></pre> <p>To make a picture for calibration press <code>SPACE</code> Do this approximately 10 times with the chessboard in view of the camera</p> <p>After that press <code>ESC</code> which will start the calibration.</p> <p>When the calibration is done, the camera will be used again to find the distance to the checkerboard.</p> <p></p>"},{"location":"examples/ros2-nav2/","title":"Navigation 2 example","text":"<p>The <code>nav2</code> example is located in the pixi repository.</p> <pre><code>git clone https://github.com/prefix-dev/pixi.git\n</code></pre> <p>Move to the example folder</p> <pre><code>cd pixi/examples/ros2-nav2\n</code></pre> <p>Run the <code>start</code> command</p> <pre><code>pixi run start\n</code></pre>"}]}