name: Release

on:
  push:
    branches: [main]
    paths:
      - "crates/pixi/Cargo.toml"
  workflow_dispatch:
    inputs:
      dry-run:
        description: "Dry run (build everything but don't create release)"
        type: boolean
        default: true

permissions:
  contents: read

env:
  CARGO_INCREMENTAL: 0
  CARGO_NET_RETRY: 10
  RUSTUP_MAX_RETRIES: 10
  CARGO_TERM_COLOR: always
  PIXI_FEATURES: "self_update,performance"

jobs:
  # ---------------------------------------------------------------------------
  # Metadata: read version from Cargo.toml, detect if it changed, generate changelog
  # ---------------------------------------------------------------------------
  metadata:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.meta.outputs.version }}
      tag: ${{ steps.meta.outputs.tag }}
      is-prerelease: ${{ steps.meta.outputs.is-prerelease }}
      publishing: ${{ steps.meta.outputs.publishing }}
      should-run: ${{ steps.meta.outputs.should-run }}
      changelog: ${{ steps.changelog.outputs.content }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Extract version and determine if release is needed
        id: meta
        shell: bash
        run: |
          # Always read version from the source of truth: Cargo.toml
          VERSION=$(grep -m1 '^version' crates/pixi/Cargo.toml | sed 's/.*"\(.*\)".*/\1/')
          TAG="v${VERSION}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

          # Check if prerelease (contains hyphen, e.g. 0.65.0-rc.1)
          if [[ "$VERSION" == *-* ]]; then
            echo "is-prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "is-prerelease=false" >> "$GITHUB_OUTPUT"
          fi

          # Determine if we should actually run and publish
          DRY_RUN="${{ inputs.dry-run }}"
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "should-run=true" >> "$GITHUB_OUTPUT"
            echo "publishing=false" >> "$GITHUB_OUTPUT"
            echo "Dry run mode: will build but not publish"
          elif git rev-parse "$TAG" >/dev/null 2>&1; then
            # Tag already exists — this version was already released
            echo "should-run=false" >> "$GITHUB_OUTPUT"
            echo "publishing=false" >> "$GITHUB_OUTPUT"
            echo "Tag $TAG already exists, skipping release"
          else
            echo "should-run=true" >> "$GITHUB_OUTPUT"
            echo "publishing=true" >> "$GITHUB_OUTPUT"
            echo "New version $VERSION detected, will build and publish as $TAG"
          fi

      - name: Generate changelog
        if: steps.meta.outputs.should-run == 'true'
        id: changelog
        shell: bash
        run: |
          # Install git-cliff if available, otherwise use git log
          if command -v git-cliff &>/dev/null; then
            CHANGELOG=$(git-cliff --latest --strip header 2>/dev/null || echo "")
          else
            cargo install git-cliff --locked 2>/dev/null || true
            if command -v git-cliff &>/dev/null; then
              CHANGELOG=$(git-cliff --latest --strip header 2>/dev/null || echo "")
            fi
          fi

          if [[ -z "$CHANGELOG" ]]; then
            # Fallback: generate from git log since last tag
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [[ -n "$PREV_TAG" ]]; then
              CHANGELOG=$(git log "$PREV_TAG"..HEAD --pretty=format:"- %s (%h)" --no-merges)
            else
              CHANGELOG="Release v${{ steps.meta.outputs.version }}"
            fi
          fi

          # Write to file to avoid quoting issues
          echo "$CHANGELOG" > "$RUNNER_TEMP/changelog.md"
          {
            echo "content<<CHANGELOG_EOF"
            cat "$RUNNER_TEMP/changelog.md"
            echo "CHANGELOG_EOF"
          } >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # Build matrix: compile pixi for all target triples
  # ---------------------------------------------------------------------------
  build:
    name: build (${{ matrix.target }})
    needs: [metadata]
    if: ${{ needs.metadata.outputs.should-run == 'true' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # ---- Linux ----
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            runner: 8core_ubuntu_latest_runner
            cross: false

          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
            runner: 8core_ubuntu_latest_runner
            cross: true

          - target: riscv64gc-unknown-linux-gnu
            os: ubuntu-latest
            runner: 8core_ubuntu_latest_runner
            cross: true

          # ---- macOS ----
          - target: aarch64-apple-darwin
            os: macos-latest
            runner: macos-latest
            cross: false

          - target: x86_64-apple-darwin
            os: macos-latest
            runner: macos-latest
            cross: false

          # ---- Windows ----
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            runner: windows_x64_2025_large
            cross: false

          - target: aarch64-pc-windows-msvc
            os: windows-latest
            runner: windows_x64_2025_large
            cross: true

    runs-on: ${{ matrix.runner }}
    permissions:
      attestations: write
      id-token: write
    env:
      BINARY_NAME: pixi
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          persist-credentials: false

      - name: Enable Windows longpaths
        if: runner.os == 'Windows'
        run: git config --global core.longpaths true

      # -- Toolchain setup --
      - name: Install Rust toolchain
        shell: bash
        run: |
          rustup toolchain install stable --profile minimal
          rustup target add ${{ matrix.target }}

      # -- Cross-compilation tools (Linux only) --
      - name: Install zig
        if: runner.os == 'Linux' && matrix.cross && !contains(matrix.target, 'riscv64')
        uses: mlugg/setup-zig@v2
        with:
          version: 0.13.0

      - name: Install cargo-zigbuild
        if: runner.os == 'Linux' && matrix.cross && !contains(matrix.target, 'riscv64')
        uses: baptiste0928/cargo-install@v3
        with:
          crate: cargo-zigbuild
          version: "0.20.1"

      - name: Install Linux build dependencies
        if: runner.os == 'Linux'
        shell: bash
        run: |
          sudo apt-get update
          case "${{ matrix.target }}" in
            x86_64-*-musl)
              # musl-tools provides musl-gcc needed by cc-rs for C dependencies
              sudo apt-get install -y musl-tools
              ;;
            aarch64-*)
              sudo apt-get install -y gcc-aarch64-linux-gnu
              ;;
            riscv64*)
              # Use system cross-compiler (zig's glibc headers are incomplete for riscv64)
              sudo apt-get install -y gcc-riscv64-linux-gnu g++-riscv64-linux-gnu libc6-dev-riscv64-cross
              ;;
          esac

      # -- Build --
      - name: Build binary
        shell: bash
        run: |
          # Use jemalloc with larger page size on aarch64/ppc64le linux
          if [[ "${{ matrix.target }}" == aarch64-unknown-linux* ]] || [[ "${{ matrix.target }}" == *ppc64le* ]]; then
            export JEMALLOC_SYS_WITH_LG_PAGE=16
            echo "Setting JEMALLOC_SYS_WITH_LG_PAGE=$JEMALLOC_SYS_WITH_LG_PAGE"
          fi

          CARGO_FLAGS=(
            --release
            --target "${{ matrix.target }}"
            --features "$PIXI_FEATURES"
            -p pixi
          )

          # Use profile settings matching the old dist profile
          export CARGO_PROFILE_RELEASE_LTO=fat
          export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
          export CARGO_PROFILE_RELEASE_OPT_LEVEL=3
          export CARGO_PROFILE_RELEASE_STRIP=symbols

          if [[ "${{ runner.os }}" == "Linux" && "${{ matrix.cross }}" == "true" && "${{ matrix.target }}" != riscv64* ]]; then
            # Linux cross-compilation uses zigbuild (except riscv64 where zig headers are incomplete)
            cargo zigbuild "${CARGO_FLAGS[@]}"
          else
            # Native build, or riscv64 cross-compile with system gcc
            cargo build "${CARGO_FLAGS[@]}"
          fi

      - name: Determine binary path
        id: binary
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            BINARY="target/${{ matrix.target }}/release/${BINARY_NAME}.exe"
          else
            BINARY="target/${{ matrix.target }}/release/${BINARY_NAME}"
          fi
          echo "path=$BINARY" >> "$GITHUB_OUTPUT"
          echo "Built binary: $BINARY"
          ls -la "$BINARY"

      # =====================================================================
      # macOS Code Signing & Notarization
      # =====================================================================
      - name: macOS - Import signing certificate
        if: runner.os == 'macOS'
        env:
          CODESIGN_CERTIFICATE: ${{ secrets.CODESIGN_CERTIFICATE }}
          CODESIGN_CERTIFICATE_PASSWORD: ${{ secrets.CODESIGN_CERTIFICATE_PASSWORD }}
        shell: bash
        run: |
          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD=$(openssl rand -hex 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$CODESIGN_CERTIFICATE" | base64 --decode > "$CERT_PATH"
          security import "$CERT_PATH" \
            -P "$CODESIGN_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Set keychain to be used
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: macOS - Sign binary
        if: runner.os == 'macOS'
        env:
          CODESIGN_IDENTITY: ${{ secrets.CODESIGN_IDENTITY }}
        shell: bash
        run: |
          codesign --force --options runtime \
            --keychain "$KEYCHAIN_PATH" \
            --sign "$CODESIGN_IDENTITY" \
            --timestamp \
            ${{ vars.CODESIGN_ADDITIONAL_ARGS }} \
            "${{ steps.binary.outputs.path }}"

          # Verify the signature
          codesign --verify --verbose "${{ steps.binary.outputs.path }}"

      - name: macOS - Notarize binary
        if: runner.os == 'macOS'
        env:
          APPLEID_USERNAME: ${{ secrets.APPLEID_USERNAME }}
          APPLEID_PASSWORD: ${{ secrets.APPLEID_PASSWORD }}
          APPLEID_TEAMID: ${{ secrets.APPLEID_TEAMID }}
        shell: bash
        run: |
          # Create a zip for notarization
          NOTARIZE_ZIP="$RUNNER_TEMP/pixi-notarize.zip"
          ditto -c -k --keepParent "${{ steps.binary.outputs.path }}" "$NOTARIZE_ZIP"

          # Submit for notarization
          xcrun notarytool submit "$NOTARIZE_ZIP" \
            --apple-id "$APPLEID_USERNAME" \
            --password "$APPLEID_PASSWORD" \
            --team-id "$APPLEID_TEAMID" \
            --wait --timeout 10m

      - name: macOS - Cleanup keychain
        if: runner.os == 'macOS' && always()
        shell: bash
        run: |
          if [[ -n "$KEYCHAIN_PATH" ]]; then
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          fi

      # =====================================================================
      # Windows Azure Trusted Signing
      # =====================================================================
      - name: Windows - Azure login (OIDC)
        if: runner.os == 'Windows'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Windows - Sign binary
        if: runner.os == 'Windows'
        uses: azure/trusted-signing-action@v1
        with:
          endpoint: ${{ vars.AZURE_SIGNING_ENDPOINT }}
          trusted-signing-account-name: ${{ vars.AZURE_SIGNING_ACCOUNT_NAME }}
          certificate-profile-name: ${{ vars.AZURE_CERTIFICATE_PROFILE_NAME }}
          files-folder: target/${{ matrix.target }}/release
          files-folder-filter: exe
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      # =====================================================================
      # Package: archives and MSI
      # =====================================================================
      - name: Create archive
        id: archive
        shell: bash
        run: |
          VERSION="${{ needs.metadata.outputs.version }}"
          TARGET="${{ matrix.target }}"
          ARCHIVE_NAME="pixi-${TARGET}"

          mkdir -p staging

          if [[ "${{ runner.os }}" == "Windows" ]]; then
            cp "${{ steps.binary.outputs.path }}" staging/pixi.exe
            ARCHIVE_FILE="${ARCHIVE_NAME}.zip"
            cd staging && 7z a "../${ARCHIVE_FILE}" pixi.exe && cd ..
          else
            cp "${{ steps.binary.outputs.path }}" staging/pixi
            ARCHIVE_FILE="${ARCHIVE_NAME}.tar.gz"
            tar -czf "${ARCHIVE_FILE}" -C staging pixi
          fi

          echo "file=${ARCHIVE_FILE}" >> "$GITHUB_OUTPUT"
          echo "name=${ARCHIVE_NAME}" >> "$GITHUB_OUTPUT"
          ls -la "${ARCHIVE_FILE}"

      # -- MSI Installer (Windows only) --
      - name: Install cargo-wix
        if: runner.os == 'Windows'
        uses: baptiste0928/cargo-install@v3
        with:
          crate: cargo-wix
          version: "0.3"

      - name: Build MSI installer
        if: runner.os == 'Windows'
        id: msi
        shell: bash
        run: |
          TARGET="${{ matrix.target }}"
          MSI_FILE="pixi-${TARGET}.msi"

          # The WXS references resources via relative paths like "wix\resources\Banner.bmp"
          # and "LICENSE". These are relative to CWD, but cargo-wix runs from workspace root.
          # Create the expected directory structure so WiX can find them.
          mkdir -p wix/resources
          cp crates/pixi/wix/resources/* wix/resources/
          cp LICENSE wix/resources/ 2>/dev/null || true

          cargo wix --no-build \
            --nocapture \
            --target "$TARGET" \
            --package pixi \
            --output "${MSI_FILE}"

          echo "file=${MSI_FILE}" >> "$GITHUB_OUTPUT"
          ls -la "${MSI_FILE}"

      - name: Windows - Sign MSI
        if: runner.os == 'Windows'
        uses: azure/trusted-signing-action@v1
        with:
          endpoint: ${{ vars.AZURE_SIGNING_ENDPOINT }}
          trusted-signing-account-name: ${{ vars.AZURE_SIGNING_ACCOUNT_NAME }}
          certificate-profile-name: ${{ vars.AZURE_CERTIFICATE_PROFILE_NAME }}
          files-folder: .
          files-folder-filter: msi
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      # -- Build attestation --
      - name: Attest build provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            ${{ steps.archive.outputs.file }}
            ${{ steps.msi.outputs.file }}

      # -- Upload artifacts --
      - name: Upload archive
        uses: actions/upload-artifact@v4
        with:
          name: archive-${{ matrix.target }}
          path: ${{ steps.archive.outputs.file }}

      - name: Upload MSI
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: msi-${{ matrix.target }}
          path: ${{ steps.msi.outputs.file }}

      - name: Upload bare binary
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.target }}
          path: ${{ steps.binary.outputs.path }}

  # ---------------------------------------------------------------------------
  # Generate checksums and collect install scripts
  # ---------------------------------------------------------------------------
  checksums:
    needs: [metadata, build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Download all archives
        uses: actions/download-artifact@v4
        with:
          pattern: archive-*
          path: dist/
          merge-multiple: true

      - name: Download all MSIs
        uses: actions/download-artifact@v4
        with:
          pattern: msi-*
          path: dist/
          merge-multiple: true

      - name: Generate checksums
        working-directory: dist
        run: |
          sha256sum * > pixi-SHA256SUMS.txt
          cat pixi-SHA256SUMS.txt

      - name: Upload checksums
        uses: actions/upload-artifact@v4
        with:
          name: checksums
          path: dist/pixi-SHA256SUMS.txt

      - name: Upload install scripts
        uses: actions/upload-artifact@v4
        with:
          name: install-scripts
          path: |
            install/install.sh
            install/install.ps1

  # ---------------------------------------------------------------------------
  # Create GitHub Release with all artifacts
  # ---------------------------------------------------------------------------
  release:
    needs: [metadata, build, checksums]
    if: ${{ needs.metadata.outputs.publishing == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Download all release artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "{archive-*,msi-*,checksums,install-scripts}"
          path: release-artifacts/
          merge-multiple: true

      - name: List release artifacts
        run: ls -laR release-artifacts/

      - name: Create tag and GitHub Release
        env:
          TAG: ${{ needs.metadata.outputs.tag }}
          VERSION: ${{ needs.metadata.outputs.version }}
          IS_PRERELEASE: ${{ needs.metadata.outputs.is-prerelease }}
          CHANGELOG: ${{ needs.metadata.outputs.changelog }}
        run: |
          PRERELEASE_FLAG=""
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          # Write release notes from env var (avoids quoting issues)
          echo "$CHANGELOG" > "$RUNNER_TEMP/release-notes.md"

          # gh release create will create the tag on the target commit
          # if it doesn't exist yet — tag + release are created atomically
          gh release create "$TAG" \
            --target "${{ github.sha }}" \
            --title "pixi $VERSION" \
            --notes-file "$RUNNER_TEMP/release-notes.md" \
            --draft \
            $PRERELEASE_FLAG \
            release-artifacts/*
