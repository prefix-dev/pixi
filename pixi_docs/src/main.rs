use clap::builder::Str;
use clap::{Command, CommandFactory, Parser};
use itertools::Itertools;
use std::error::Error;
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};

const MD_EXTENSION: &str = ".md";
const RECURSIVE_COMMANDS: &[&str] = &["pixi", "project", "global"];

#[derive(Parser)]
#[command(about = "Generates markdown documentation for the Pixi CLI")]
struct Cli {
    /// Output directory for the generated documentation
    #[arg(short, long, default_value = "../docs/autogenerated")]
    output_dir: PathBuf,
}

/// Generates documentation for the Pixi CLI by:
/// - Loading the clap command from the pixi crate
/// - Creating markdown files for each command
/// - Organizing commands into a directory structure
fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let command = get_command();
    println!("Version: {}\n", command.get_version().unwrap_or("unknown"));
    process_subcommands(&command, Vec::new(), &cli.output_dir)?;
    Ok(())
}

/// Processes a command and its subcommands, generating markdown documentation
fn process_subcommands(
    command: &Command,
    parent_path: Vec<String>,
    output_dir: &Path,
) -> Result<(), Box<dyn Error>> {
    let mut current_path = parent_path;
    current_path.push(command.get_name().to_string());

    let command_file_name = format!("{}{}", current_path.join("/"), MD_EXTENSION);
    let command_file_path = output_dir.join(&command_file_name);

    fs::create_dir_all(command_file_path.parent().ok_or("Invalid path")?)
        .map_err(|e| format!("Failed to create directories: {}", e))?;
    fs::write(
        &command_file_path,
        subcommand_to_md(&current_path[..current_path.len() - 1], command),
    )
        .map_err(|e| format!("Failed to write command file {}: {}", command_file_path.display(), e))?;

    if RECURSIVE_COMMANDS.contains(&command.get_name()) {
        for subcommand in command.get_subcommands() {
            process_subcommands(subcommand, current_path.clone(), output_dir)?;
        }
    }
    Ok(())
}

/// Generates a command synopsis string
fn subcommand_to_synopsis(parents: &[String], command: &Command) -> String {
    let mut buffer = String::with_capacity(100);
    write!(buffer, "{} {}", parents.join(" "), command.get_name()).unwrap();

    let positionals: Vec<_> = command
        .get_positionals()
        .flat_map(|p| p.get_value_names().map(|n| format!("[{}]", n.join(" "))))
        .collect();

    if !positionals.is_empty() {
        write!(buffer, " {}", positionals.join(" ")).unwrap();
    }
    buffer
}

/// Converts a command to Markdown format
fn subcommand_to_md(parents: &[String], command: &Command) -> String {
    let mut buffer = String::with_capacity(1024);

    // Name with correct relative links including .md extension
    let mut name_parts = Vec::new();
    let depth = parents.len() + 1; // Total depth including current command

    // Handle parents
    for (i, parent) in parents.iter().enumerate() {
        let ups = depth - i - 1;
        let relative_path = if ups > 0 {
            format!("{}{}.md", "../".repeat(ups), parent)
        } else {
            format!("{}.md", parent)
        };
        name_parts.push(format!("[`{}`]({})", parent, relative_path));
    }

    // Add current command without link
    name_parts.push(format!("`{}`", command.get_name()));

    writeln!(buffer, "# {}", name_parts.join("")).unwrap();

    // Synopsis
    writeln!(buffer, "\n## Synopsis").unwrap();
    writeln!(buffer, "```").unwrap();
    writeln!(buffer, "{}", subcommand_to_synopsis(parents, command)).unwrap();
    for subcommand in command.get_subcommands() {
        let mut path = parents.to_vec();
        path.push(command.get_name().to_string());
        writeln!(buffer, "{}", subcommand_to_synopsis(&path, subcommand)).unwrap();
    }
    writeln!(buffer, "```").unwrap();

    // About
    if let Some(about) = command.get_about() {
        writeln!(buffer, "\n## About").unwrap();
        writeln!(buffer, "{}", about).unwrap();
    }

    // Positionals
    let positionals: Vec<_> = command.get_positionals().collect();
    if !positionals.is_empty() {
        writeln!(buffer, "\n## Arguments").unwrap();
        for pos in positionals {
            write!(
                buffer,
                "- **{}**",
                pos.get_value_names().unwrap_or(&[Str::from("")]).join(" ")
            )
                .unwrap();
            if let Some(help) = pos.get_long_help().or(pos.get_help()) {
                writeln!(buffer, ": {}", help).unwrap();
            } else {
                writeln!(buffer).unwrap();
            }
        }
    }

    // Options
    let opts: Vec<_> = command.get_opts().collect();
    if !opts.is_empty() {
        writeln!(buffer, "\n## Options").unwrap();
        let sorted_opts: Vec<_> = opts
            .into_iter()
            .filter(|o| !o.is_hide_set())
            .sorted_by(|a, b| {
                a.get_long()
                    .unwrap_or_default()
                    .cmp(&b.get_long().unwrap_or_default())
            })
            .sorted_by(|a, b| a.is_global_set().cmp(&b.is_global_set()))
            .collect();

        for opt in sorted_opts {
            let global = if opt.is_global_set() { "global: " } else { "" };
            write!(
                buffer,
                "- {}**`--{}`**",
                global,
                opt.get_long().unwrap_or_default()
            )
                .unwrap();
            if let Some(aliases) = opt.get_all_aliases() {
                if !aliases.is_empty() {
                    write!(buffer, " (aliases: {})", aliases.join(", ")).unwrap();
                }
            }
            writeln!(buffer, ": {}", opt.get_help().unwrap_or_default()).unwrap();
        }
    }

    // Long about
    if let Some(long) = command.get_long_about() {
        writeln!(buffer, "\n## Description").unwrap();
        writeln!(buffer, "{}\n", long).unwrap();
    }

    // Subcommands
    if command.has_subcommands() {
        writeln!(buffer, "\n## Subcommands").unwrap();
        let will_recurse = RECURSIVE_COMMANDS.contains(&command.get_name());

        for subcommand in command.get_subcommands() {
            if subcommand.is_hide_set() {
                continue;
            }
            let about = if let Some(about) = subcommand.get_about() {
                format!(": {about}")
            } else {
                "".to_string()
            };

            if will_recurse {
                // Generate link only if this command will recurse, without .md
                let path = vec![command.get_name(), subcommand.get_name()];

                writeln!(
                    buffer,
                    "### [{}]({}.md)",
                    subcommand.get_name(),
                    path.join("/")
                )
                    .unwrap();
                write!(buffer, "{}\n\n", about).unwrap();
            } else {
                // Plain text for non-recursive subcommands
                writeln!(buffer, "### `{}`", subcommand.get_name()).unwrap();
                write!(buffer, "{}\n\n", about).unwrap();
            }
        }
    }

    buffer
}

/// Loads the CLI command structure from pixi
fn get_command() -> Command {
    pixi::cli::Args::command()
}
