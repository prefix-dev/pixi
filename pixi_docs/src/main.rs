use clap::builder::Str;
use clap::{Command, CommandFactory, Parser};
use itertools::Itertools;
use std::error::Error;
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};

const MD_EXTENSION: &str = ".md";
// const RECURSIVE_COMMANDS: &[&str] = &["pixi", "project", "global"];

#[derive(Parser)]
#[command(about = "Generates markdown documentation for the Pixi CLI")]
struct Cli {
    /// Output directory for the generated documentation
    #[arg(short, long, default_value = "../docs/autogenerated")]
    output_dir: PathBuf,
}

/// Generates documentation for the Pixi CLI by:
/// - Loading the clap command from the pixi crate
/// - Creating markdown files for each command
/// - Organizing commands into a directory structure
fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let command = get_command();
    println!("Version: {}\n", command.get_version().unwrap_or("unknown"));
    process_subcommands(&command, Vec::new(), &cli.output_dir)?;
    Ok(())
}

/// Processes a command and its subcommands, generating markdown documentation
fn process_subcommands(
    command: &Command,
    parent_path: Vec<String>,
    output_dir: &Path,
) -> Result<(), Box<dyn Error>> {
    let mut current_path = parent_path;
    current_path.push(command.get_name().to_string());

    let command_file_name = format!("{}{}", current_path.join("/"), MD_EXTENSION);
    let command_file_path = output_dir.join(&command_file_name);

    fs::create_dir_all(command_file_path.parent().ok_or("Invalid path")?)
        .map_err(|e| format!("Failed to create directories: {}", e))?;
    fs::write(
        &command_file_path,
        subcommand_to_md(&current_path[..current_path.len() - 1], command),
    )
        .map_err(|e| format!("Failed to write command file {}: {}", command_file_path.display(), e))?;

    // if RECURSIVE_COMMANDS.contains(&command.get_name()) {
    for subcommand in command.get_subcommands() {
        process_subcommands(subcommand, current_path.clone(), output_dir)?;
    }
    // }
    Ok(())
}

/// Converts a command to Markdown format
fn subcommand_to_md(parents: &[String], command: &Command) -> String {
    let mut buffer = String::with_capacity(1024);

    // Parent path for relative links
    let parent_path = if parents.is_empty() {
        "".to_string()
    } else {
        format!("{}/", parents.join("/"))
    };

    // Name with correct relative links including .md extension
    let mut name_parts = Vec::new();
    let depth = parents.len() + 1; // Total depth including current command

    // Handle parents
    for (i, parent) in parents.iter().enumerate() {
        let ups = depth - i - 1;
        let relative_path = if ups > 0 {
            format!("{}{}.md", "../".repeat(ups), parent)
        } else {
            format!("{}.md", parent)
        };
        name_parts.push(format!("[`{}`]({})", parent, relative_path));
    }

    // Add current command without link
    name_parts.push(format!("`{}`", command.get_name()));

    // Title
    writeln!(buffer, "# {}", name_parts.join("")).unwrap();

    // About
    if command.get_name() != "pixi" {
        if let Some(about) = command.get_about() {
            writeln!(buffer, "\n## About").unwrap();
            writeln!(buffer, "{}", about).unwrap();
        }
    }

    // Additional description
    writeln!(buffer, "\n--8<-- \"docs/reference/cli/{}{}.md:description\"", parent_path, command.get_name()).unwrap();

    // Positionals
    let positionals: Vec<_> = command.get_positionals().collect();
    if !positionals.is_empty() {
        writeln!(buffer, "\n## Arguments").unwrap();
        for pos in positionals {
            write!(
                buffer,
                "- **{}**{}",
                pos.get_value_names().unwrap_or(&[Str::from("")]).join(" "),
                if pos.is_required_set() { " *required*" } else { "" }
            )
                .unwrap();

            if let Some(help) = pos.get_long_help().or(pos.get_help()) {
                write!(buffer, ": {}", help).unwrap();
            }

            if !pos.get_possible_values().is_empty() {
                write!(buffer, " **options**: `{}`", pos.get_possible_values().iter().map(|value| value.get_name()).join("`, `")).unwrap();
            }

            if !pos.get_default_values().is_empty() {
                write!(buffer, " **defaults**: `{}`", pos.get_default_values().iter().map(|value| value.to_string_lossy()).join(", ")).unwrap();
            }

            writeln!(buffer).unwrap();
        }
    }

    // Options
    let opts: Vec<_> = command.get_opts().collect();
    if !opts.is_empty() {
        writeln!(buffer, "\n## Options").unwrap();
        let sorted_opts: Vec<_> = opts
            .into_iter()
            .filter(|o| !o.is_hide_set())
            .sorted_by(|a, b| {
                a.get_long()
                    .unwrap_or_default()
                    .cmp(&b.get_long().unwrap_or_default())
            })
            .sorted_by(|a, b| a.is_global_set().cmp(&b.is_global_set()))
            .collect();

        for opt in sorted_opts {
            if opt.is_hide_set() || opt.get_long().is_none() {
                continue;
            }

            let long_name = opt.get_long().unwrap_or_default();
            let id = format!("option-{}", long_name); // Generate a unique ID for each option

            // Start with the span for the ID
            write!(buffer, "<span id=\"{}\"></span>\n", id).unwrap();

            let global = if opt.is_global_set() { "**global**: " } else { "" };

            // Write the option as a bullet point with a clickable link
            write!(
                buffer,
                "- {}**[`--{}{}{}`](#{})**  \n:",
                global,
                long_name,
                if let Some(short) = opt.get_short() {
                    format!(" (-{})", short)
                } else {
                    "".to_string()
                },
                if opt.get_action().takes_values() {
                    if let Some(value_names) = opt.get_value_names() {
                        format!(" {}", value_names.join(" "))
                    } else {
                        "".to_string()
                    }
                } else {
                    "".to_string()
                },
                id
            )
                .unwrap();

            // Write the help text on the next line, indented appropriately
            write!(buffer, "  {}\n", opt.get_help().unwrap_or_default()).unwrap();

            // Handle aliases, env, defaults, and options on separate lines with proper indentation
            if let Some(aliases) = opt.get_visible_aliases() {
                if !aliases.is_empty() {
                    write!(buffer, "<br>**aliases**: {}\n", aliases.join(", ")).unwrap();
                }
            }

            if let Some(env) = opt.get_env() {
                write!(buffer, "<br>**env**: `{}`\n", env.to_string_lossy()).unwrap();
            }

            if !opt.get_default_values().is_empty() {
                write!(
                    buffer,
                    "<br>**defaults**: `{}`\n",
                    opt.get_default_values()
                        .iter()
                        .map(|value| value.to_string_lossy())
                        .join(", ")
                )
                    .unwrap();
            }

            if opt.get_action().takes_values() && !opt.get_possible_values().is_empty() {
                write!(
                    buffer,
                    "<br>**options**: `{}`\n",
                    opt.get_possible_values()
                        .iter()
                        .map(|value| value.get_name())
                        .join("`, `")
                )
                    .unwrap();
            }
            writeln!(buffer).unwrap();
        }
    }

    // Subcommands
    if command.has_subcommands() {
        writeln!(buffer, "\n## Subcommands").unwrap();
        let subcommands: Vec<_> = command.get_subcommands().collect();
        if !subcommands.is_empty() {
            writeln!(buffer, "{}", subcommands_table(subcommands)).unwrap();
        }
    }

    // Long about
    if let Some(long) = command.get_long_about() {
        writeln!(buffer, "\n## Description").unwrap();
        writeln!(buffer, "{}\n", long).unwrap();
    }

    // Write snippet link
    writeln!(buffer, "\n--8<-- \"docs/reference/cli/{}{}.md:example\"", parent_path, command.get_name()).unwrap();

    buffer
}

/// Generates a Markdown table of subcommands with command names as links to their pages
fn subcommands_table(subcommands: Vec<&Command>) -> String {
    let mut buffer = String::with_capacity(1024);
    writeln!(buffer, "| Command | Description |").unwrap();
    writeln!(buffer, "|---------|-------------|").unwrap();
    for subcommand in subcommands {
        // Skip hidden subcommands
        if subcommand.is_hide_set() {
            continue;
        }
        // Create a link to the subcommand's Markdown file
        let command_name = subcommand.get_name();
        let link = format!("[`{}`]({})", command_name, command_name);
        writeln!(
            buffer,
            "| {} | {} |",
            link,
            subcommand.get_about().unwrap_or_default()
        )
            .unwrap();
    }
    buffer
}

/// Loads the CLI command structure from pixi
fn get_command() -> Command {
    pixi::cli::Args::command()
}
